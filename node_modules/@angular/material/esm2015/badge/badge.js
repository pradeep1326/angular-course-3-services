/**
 * @fileoverview added by tsickle
 * Generated from: src/material/badge/badge.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AriaDescriber } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Directive, ElementRef, Inject, Input, NgZone, Optional, Renderer2, isDevMode, } from '@angular/core';
import { mixinDisabled } from '@angular/material/core';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/a11y';
let nextId = 0;
// Boilerplate for applying mixins to MatBadge.
/**
 * \@docs-private
 */
class MatBadgeBase {
}
/** @type {?} */
const _MatBadgeMixinBase = mixinDisabled(MatBadgeBase);
/**
 * Directive to display a text badge.
 */
export class MatBadge extends _MatBadgeMixinBase {
    /**
     * @param {?} _ngZone
     * @param {?} _elementRef
     * @param {?} _ariaDescriber
     * @param {?} _renderer
     * @param {?=} _animationMode
     */
    constructor(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {
        super();
        this._ngZone = _ngZone;
        this._elementRef = _elementRef;
        this._ariaDescriber = _ariaDescriber;
        this._renderer = _renderer;
        this._animationMode = _animationMode;
        /**
         * Whether the badge has any content.
         */
        this._hasContent = false;
        this._color = 'primary';
        this._overlap = true;
        /**
         * Position the badge should reside.
         * Accepts any combination of 'above'|'below' and 'before'|'after'
         */
        this.position = 'above after';
        /**
         * Size of the badge. Can be 'small', 'medium', or 'large'.
         */
        this.size = 'medium';
        /**
         * Unique id for the badge
         */
        this._id = nextId++;
        if (isDevMode()) {
            /** @type {?} */
            const nativeElement = _elementRef.nativeElement;
            if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {
                throw Error('matBadge must be attached to an element node.');
            }
        }
    }
    /**
     * The color of the badge. Can be `primary`, `accent`, or `warn`.
     * @return {?}
     */
    get color() { return this._color; }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._setColor(value);
        this._color = value;
    }
    /**
     * Whether the badge should overlap its contents or not
     * @return {?}
     */
    get overlap() { return this._overlap; }
    /**
     * @param {?} val
     * @return {?}
     */
    set overlap(val) {
        this._overlap = coerceBooleanProperty(val);
    }
    /**
     * Message used to describe the decorated element via aria-describedby
     * @return {?}
     */
    get description() { return this._description; }
    /**
     * @param {?} newDescription
     * @return {?}
     */
    set description(newDescription) {
        if (newDescription !== this._description) {
            /** @type {?} */
            const badgeElement = this._badgeElement;
            this._updateHostAriaDescription(newDescription, this._description);
            this._description = newDescription;
            if (badgeElement) {
                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :
                    badgeElement.removeAttribute('aria-label');
            }
        }
    }
    /**
     * Whether the badge is hidden.
     * @return {?}
     */
    get hidden() { return this._hidden; }
    /**
     * @param {?} val
     * @return {?}
     */
    set hidden(val) {
        this._hidden = coerceBooleanProperty(val);
    }
    /**
     * Whether the badge is above the host or not
     * @return {?}
     */
    isAbove() {
        return this.position.indexOf('below') === -1;
    }
    /**
     * Whether the badge is after the host or not
     * @return {?}
     */
    isAfter() {
        return this.position.indexOf('before') === -1;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const contentChange = changes['content'];
        if (contentChange) {
            /** @type {?} */
            const value = contentChange.currentValue;
            this._hasContent = value != null && `${value}`.trim().length > 0;
            this._updateTextContent();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** @type {?} */
        const badgeElement = this._badgeElement;
        if (badgeElement) {
            if (this.description) {
                this._ariaDescriber.removeDescription(badgeElement, this.description);
            }
            // When creating a badge through the Renderer, Angular will keep it in an index.
            // We have to destroy it ourselves, otherwise it'll be retained in memory.
            if (this._renderer.destroyNode) {
                this._renderer.destroyNode(badgeElement);
            }
        }
    }
    /**
     * Gets the element into which the badge's content is being rendered.
     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).
     * @return {?}
     */
    getBadgeElement() {
        return this._badgeElement;
    }
    /**
     * Injects a span element into the DOM with the content.
     * @private
     * @return {?}
     */
    _updateTextContent() {
        if (!this._badgeElement) {
            this._badgeElement = this._createBadgeElement();
        }
        else {
            this._badgeElement.textContent = this.content;
        }
        return this._badgeElement;
    }
    /**
     * Creates the badge element
     * @private
     * @return {?}
     */
    _createBadgeElement() {
        /** @type {?} */
        const badgeElement = this._renderer.createElement('span');
        /** @type {?} */
        const activeClass = 'mat-badge-active';
        /** @type {?} */
        const contentClass = 'mat-badge-content';
        // Clear any existing badges which may have persisted from a server-side render.
        this._clearExistingBadges(contentClass);
        badgeElement.setAttribute('id', `mat-badge-content-${this._id}`);
        badgeElement.classList.add(contentClass);
        badgeElement.textContent = this.content;
        if (this._animationMode === 'NoopAnimations') {
            badgeElement.classList.add('_mat-animation-noopable');
        }
        if (this.description) {
            badgeElement.setAttribute('aria-label', this.description);
        }
        this._elementRef.nativeElement.appendChild(badgeElement);
        // animate in after insertion
        if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                requestAnimationFrame((/**
                 * @return {?}
                 */
                () => {
                    badgeElement.classList.add(activeClass);
                }));
            }));
        }
        else {
            badgeElement.classList.add(activeClass);
        }
        return badgeElement;
    }
    /**
     * Sets the aria-label property on the element
     * @private
     * @param {?} newDescription
     * @param {?} oldDescription
     * @return {?}
     */
    _updateHostAriaDescription(newDescription, oldDescription) {
        // ensure content available before setting label
        /** @type {?} */
        const content = this._updateTextContent();
        if (oldDescription) {
            this._ariaDescriber.removeDescription(content, oldDescription);
        }
        if (newDescription) {
            this._ariaDescriber.describe(content, newDescription);
        }
    }
    /**
     * Adds css theme class given the color to the component host
     * @private
     * @param {?} colorPalette
     * @return {?}
     */
    _setColor(colorPalette) {
        if (colorPalette !== this._color) {
            if (this._color) {
                this._elementRef.nativeElement.classList.remove(`mat-badge-${this._color}`);
            }
            if (colorPalette) {
                this._elementRef.nativeElement.classList.add(`mat-badge-${colorPalette}`);
            }
        }
    }
    /**
     * Clears any existing badges that might be left over from server-side rendering.
     * @private
     * @param {?} cssClass
     * @return {?}
     */
    _clearExistingBadges(cssClass) {
        /** @type {?} */
        const element = this._elementRef.nativeElement;
        /** @type {?} */
        let childCount = element.children.length;
        // Use a reverse while, because we'll be removing elements from the list as we're iterating.
        while (childCount--) {
            /** @type {?} */
            const currentChild = element.children[childCount];
            if (currentChild.classList.contains(cssClass)) {
                element.removeChild(currentChild);
            }
        }
    }
}
MatBadge.ɵfac = function MatBadge_Factory(t) { return new (t || MatBadge)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AriaDescriber), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
MatBadge.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatBadge, selectors: [["", "matBadge", ""]], hostAttrs: [1, "mat-badge"], hostVars: 20, hostBindings: function MatBadge_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-badge-overlap", ctx.overlap)("mat-badge-above", ctx.isAbove())("mat-badge-below", !ctx.isAbove())("mat-badge-before", !ctx.isAfter())("mat-badge-after", ctx.isAfter())("mat-badge-small", ctx.size === "small")("mat-badge-medium", ctx.size === "medium")("mat-badge-large", ctx.size === "large")("mat-badge-hidden", ctx.hidden || !ctx._hasContent)("mat-badge-disabled", ctx.disabled);
    } }, inputs: { disabled: ["matBadgeDisabled", "disabled"], position: ["matBadgePosition", "position"], size: ["matBadgeSize", "size"], color: ["matBadgeColor", "color"], overlap: ["matBadgeOverlap", "overlap"], description: ["matBadgeDescription", "description"], hidden: ["matBadgeHidden", "hidden"], content: ["matBadge", "content"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()] });
/** @nocollapse */
MatBadge.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: AriaDescriber },
    { type: Renderer2 },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
MatBadge.propDecorators = {
    color: [{ type: Input, args: ['matBadgeColor',] }],
    overlap: [{ type: Input, args: ['matBadgeOverlap',] }],
    position: [{ type: Input, args: ['matBadgePosition',] }],
    content: [{ type: Input, args: ['matBadge',] }],
    description: [{ type: Input, args: ['matBadgeDescription',] }],
    size: [{ type: Input, args: ['matBadgeSize',] }],
    hidden: [{ type: Input, args: ['matBadgeHidden',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatBadge, [{
        type: Directive,
        args: [{
                selector: '[matBadge]',
                inputs: ['disabled: matBadgeDisabled'],
                host: {
                    'class': 'mat-badge',
                    '[class.mat-badge-overlap]': 'overlap',
                    '[class.mat-badge-above]': 'isAbove()',
                    '[class.mat-badge-below]': '!isAbove()',
                    '[class.mat-badge-before]': '!isAfter()',
                    '[class.mat-badge-after]': 'isAfter()',
                    '[class.mat-badge-small]': 'size === "small"',
                    '[class.mat-badge-medium]': 'size === "medium"',
                    '[class.mat-badge-large]': 'size === "large"',
                    '[class.mat-badge-hidden]': 'hidden || !_hasContent',
                    '[class.mat-badge-disabled]': 'disabled'
                }
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.AriaDescriber }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { position: [{
            type: Input,
            args: ['matBadgePosition']
        }], size: [{
            type: Input,
            args: ['matBadgeSize']
        }], color: [{
            type: Input,
            args: ['matBadgeColor']
        }], overlap: [{
            type: Input,
            args: ['matBadgeOverlap']
        }], description: [{
            type: Input,
            args: ['matBadgeDescription']
        }], hidden: [{
            type: Input,
            args: ['matBadgeHidden']
        }], content: [{
            type: Input,
            args: ['matBadge']
        }] }); })();
if (false) {
    /** @type {?} */
    MatBadge.ngAcceptInputType_disabled;
    /** @type {?} */
    MatBadge.ngAcceptInputType_hidden;
    /** @type {?} */
    MatBadge.ngAcceptInputType_overlap;
    /**
     * Whether the badge has any content.
     * @type {?}
     */
    MatBadge.prototype._hasContent;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._color;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._overlap;
    /**
     * Position the badge should reside.
     * Accepts any combination of 'above'|'below' and 'before'|'after'
     * @type {?}
     */
    MatBadge.prototype.position;
    /**
     * The content for the badge
     * @type {?}
     */
    MatBadge.prototype.content;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._description;
    /**
     * Size of the badge. Can be 'small', 'medium', or 'large'.
     * @type {?}
     */
    MatBadge.prototype.size;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._hidden;
    /**
     * Unique id for the badge
     * @type {?}
     */
    MatBadge.prototype._id;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._badgeElement;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._ariaDescriber;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    MatBadge.prototype._animationMode;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtMjAxNS9iYWRnZS9iYWRnZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvUkMscWFBbUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUJBIiwiZmlsZSI6ImJhZGdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvbWF0ZXJpYWwvYmFkZ2UvYmFkZ2UudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBBcmlhRGVzY3JpYmVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPcHRpb25hbCwgUmVuZGVyZXIyLCBpc0Rldk1vZGUsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBtaXhpbkRpc2FibGVkIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBBTklNQVRJT05fTU9EVUxFX1RZUEUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnO1xuLyoqIEB0eXBlIHs/fSAqL1xubGV0IG5leHRJZCA9IDA7XG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1hdEJhZGdlLlxuLyoqXG4gKiBcXEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgTWF0QmFkZ2VCYXNlIHtcbn1cbi8qKiBAdHlwZSB7P30gKi9cbmNvbnN0IF9NYXRCYWRnZU1peGluQmFzZSA9IG1peGluRGlzYWJsZWQoTWF0QmFkZ2VCYXNlKTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGRpc3BsYXkgYSB0ZXh0IGJhZGdlLlxuICovXG5leHBvcnQgY2xhc3MgTWF0QmFkZ2UgZXh0ZW5kcyBfTWF0QmFkZ2VNaXhpbkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IF9hcmlhRGVzY3JpYmVyXG4gICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gez89fSBfYW5pbWF0aW9uTW9kZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZ1pvbmUsIF9lbGVtZW50UmVmLCBfYXJpYURlc2NyaWJlciwgX3JlbmRlcmVyLCBfYW5pbWF0aW9uTW9kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZXIgPSBfYXJpYURlc2NyaWJlcjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk1vZGUgPSBfYW5pbWF0aW9uTW9kZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGJhZGdlIGhhcyBhbnkgY29udGVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hhc0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIHRoaXMuX292ZXJsYXAgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gdGhlIGJhZGdlIHNob3VsZCByZXNpZGUuXG4gICAgICAgICAqIEFjY2VwdHMgYW55IGNvbWJpbmF0aW9uIG9mICdhYm92ZSd8J2JlbG93JyBhbmQgJ2JlZm9yZSd8J2FmdGVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdhYm92ZSBhZnRlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBiYWRnZS4gQ2FuIGJlICdzbWFsbCcsICdtZWRpdW0nLCBvciAnbGFyZ2UnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgaWQgZm9yIHRoZSBiYWRnZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faWQgPSBuZXh0SWQrKztcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChuYXRpdmVFbGVtZW50Lm5vZGVUeXBlICE9PSBuYXRpdmVFbGVtZW50LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdtYXRCYWRnZSBtdXN0IGJlIGF0dGFjaGVkIHRvIGFuIGVsZW1lbnQgbm9kZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIGJhZGdlLiBDYW4gYmUgYHByaW1hcnlgLCBgYWNjZW50YCwgb3IgYHdhcm5gLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGNvbG9yKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0Q29sb3IodmFsdWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBiYWRnZSBzaG91bGQgb3ZlcmxhcCBpdHMgY29udGVudHMgb3Igbm90XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMuX292ZXJsYXA7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IG92ZXJsYXAodmFsKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXAgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSB1c2VkIHRvIGRlc2NyaWJlIHRoZSBkZWNvcmF0ZWQgZWxlbWVudCB2aWEgYXJpYS1kZXNjcmliZWRieVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5ld0Rlc2NyaXB0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgZGVzY3JpcHRpb24obmV3RGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKG5ld0Rlc2NyaXB0aW9uICE9PSB0aGlzLl9kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgYmFkZ2VFbGVtZW50ID0gdGhpcy5fYmFkZ2VFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSG9zdEFyaWFEZXNjcmlwdGlvbihuZXdEZXNjcmlwdGlvbiwgdGhpcy5fZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gPSBuZXdEZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmIChiYWRnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBuZXdEZXNjcmlwdGlvbiA/IGJhZGdlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBuZXdEZXNjcmlwdGlvbikgOlxuICAgICAgICAgICAgICAgICAgICBiYWRnZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYmFkZ2UgaXMgaGlkZGVuLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0IGhpZGRlbigpIHsgcmV0dXJuIHRoaXMuX2hpZGRlbjsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbCkge1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYmFkZ2UgaXMgYWJvdmUgdGhlIGhvc3Qgb3Igbm90XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBpc0Fib3ZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmRleE9mKCdiZWxvdycpID09PSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYmFkZ2UgaXMgYWZ0ZXIgdGhlIGhvc3Qgb3Igbm90XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBpc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmRleE9mKCdiZWZvcmUnKSA9PT0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGNvbnRlbnRDaGFuZ2UgPSBjaGFuZ2VzWydjb250ZW50J107XG4gICAgICAgIGlmIChjb250ZW50Q2hhbmdlKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRlbnRDaGFuZ2UuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5faGFzQ29udGVudCA9IHZhbHVlICE9IG51bGwgJiYgYCR7dmFsdWV9YC50cmltKCkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBiYWRnZUVsZW1lbnQgPSB0aGlzLl9iYWRnZUVsZW1lbnQ7XG4gICAgICAgIGlmIChiYWRnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJpYURlc2NyaWJlci5yZW1vdmVEZXNjcmlwdGlvbihiYWRnZUVsZW1lbnQsIHRoaXMuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBjcmVhdGluZyBhIGJhZGdlIHRocm91Z2ggdGhlIFJlbmRlcmVyLCBBbmd1bGFyIHdpbGwga2VlcCBpdCBpbiBhbiBpbmRleC5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZGVzdHJveSBpdCBvdXJzZWx2ZXMsIG90aGVyd2lzZSBpdCdsbCBiZSByZXRhaW5lZCBpbiBtZW1vcnkuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIuZGVzdHJveU5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXN0cm95Tm9kZShiYWRnZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgaW50byB3aGljaCB0aGUgYmFkZ2UncyBjb250ZW50IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAqIFVuZGVmaW5lZCBpZiB0aGUgZWxlbWVudCBoYXNuJ3QgYmVlbiBjcmVhdGVkIChlLmcuIGlmIHRoZSBiYWRnZSBkb2Vzbid0IGhhdmUgY29udGVudCkuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRCYWRnZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWRnZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYSBzcGFuIGVsZW1lbnQgaW50byB0aGUgRE9NIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF91cGRhdGVUZXh0Q29udGVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9iYWRnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhZGdlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUJhZGdlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYmFkZ2VFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWRnZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGJhZGdlIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2NyZWF0ZUJhZGdlRWxlbWVudCgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBiYWRnZUVsZW1lbnQgPSB0aGlzLl9yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgYWN0aXZlQ2xhc3MgPSAnbWF0LWJhZGdlLWFjdGl2ZSc7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY29udGVudENsYXNzID0gJ21hdC1iYWRnZS1jb250ZW50JztcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGJhZGdlcyB3aGljaCBtYXkgaGF2ZSBwZXJzaXN0ZWQgZnJvbSBhIHNlcnZlci1zaWRlIHJlbmRlci5cbiAgICAgICAgdGhpcy5fY2xlYXJFeGlzdGluZ0JhZGdlcyhjb250ZW50Q2xhc3MpO1xuICAgICAgICBiYWRnZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGBtYXQtYmFkZ2UtY29udGVudC0ke3RoaXMuX2lkfWApO1xuICAgICAgICBiYWRnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChjb250ZW50Q2xhc3MpO1xuICAgICAgICBiYWRnZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25Nb2RlID09PSAnTm9vcEFuaW1hdGlvbnMnKSB7XG4gICAgICAgICAgICBiYWRnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnX21hdC1hbmltYXRpb24tbm9vcGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgYmFkZ2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hcHBlbmRDaGlsZChiYWRnZUVsZW1lbnQpO1xuICAgICAgICAvLyBhbmltYXRlIGluIGFmdGVyIGluc2VydGlvblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLl9hbmltYXRpb25Nb2RlICE9PSAnTm9vcEFuaW1hdGlvbnMnKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoLyoqXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJhZGdlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiYWRnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhZGdlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXJpYS1sYWJlbCBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBuZXdEZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gb2xkRGVzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF91cGRhdGVIb3N0QXJpYURlc2NyaXB0aW9uKG5ld0Rlc2NyaXB0aW9uLCBvbGREZXNjcmlwdGlvbikge1xuICAgICAgICAvLyBlbnN1cmUgY29udGVudCBhdmFpbGFibGUgYmVmb3JlIHNldHRpbmcgbGFiZWxcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fdXBkYXRlVGV4dENvbnRlbnQoKTtcbiAgICAgICAgaWYgKG9sZERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9hcmlhRGVzY3JpYmVyLnJlbW92ZURlc2NyaXB0aW9uKGNvbnRlbnQsIG9sZERlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3RGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZXIuZGVzY3JpYmUoY29udGVudCwgbmV3RGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgY3NzIHRoZW1lIGNsYXNzIGdpdmVuIHRoZSBjb2xvciB0byB0aGUgY29tcG9uZW50IGhvc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29sb3JQYWxldHRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfc2V0Q29sb3IoY29sb3JQYWxldHRlKSB7XG4gICAgICAgIGlmIChjb2xvclBhbGV0dGUgIT09IHRoaXMuX2NvbG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShgbWF0LWJhZGdlLSR7dGhpcy5fY29sb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3JQYWxldHRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoYG1hdC1iYWRnZS0ke2NvbG9yUGFsZXR0ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYW55IGV4aXN0aW5nIGJhZGdlcyB0aGF0IG1pZ2h0IGJlIGxlZnQgb3ZlciBmcm9tIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gY3NzQ2xhc3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jbGVhckV4aXN0aW5nQmFkZ2VzKGNzc0NsYXNzKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBsZXQgY2hpbGRDb3VudCA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAvLyBVc2UgYSByZXZlcnNlIHdoaWxlLCBiZWNhdXNlIHdlJ2xsIGJlIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIGxpc3QgYXMgd2UncmUgaXRlcmF0aW5nLlxuICAgICAgICB3aGlsZSAoY2hpbGRDb3VudC0tKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBlbGVtZW50LmNoaWxkcmVuW2NoaWxkQ291bnRdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjdXJyZW50Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuTWF0QmFkZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXRCYWRnZV0nLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZDogbWF0QmFkZ2VEaXNhYmxlZCddLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1iYWRnZScsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJhZGdlLW92ZXJsYXBdJzogJ292ZXJsYXAnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1iYWRnZS1hYm92ZV0nOiAnaXNBYm92ZSgpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYmFkZ2UtYmVsb3ddJzogJyFpc0Fib3ZlKCknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1iYWRnZS1iZWZvcmVdJzogJyFpc0FmdGVyKCknLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1iYWRnZS1hZnRlcl0nOiAnaXNBZnRlcigpJyxcbiAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYmFkZ2Utc21hbGxdJzogJ3NpemUgPT09IFwic21hbGxcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJhZGdlLW1lZGl1bV0nOiAnc2l6ZSA9PT0gXCJtZWRpdW1cIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJhZGdlLWxhcmdlXSc6ICdzaXplID09PSBcImxhcmdlXCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1iYWRnZS1oaWRkZW5dJzogJ2hpZGRlbiB8fCAhX2hhc0NvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1iYWRnZS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTWF0QmFkZ2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IEFyaWFEZXNjcmliZXIgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0FOSU1BVElPTl9NT0RVTEVfVFlQRSxdIH1dIH1cbl07XG5NYXRCYWRnZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb2xvcjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0QmFkZ2VDb2xvcicsXSB9XSxcbiAgICBvdmVybGFwOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydtYXRCYWRnZU92ZXJsYXAnLF0gfV0sXG4gICAgcG9zaXRpb246IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdEJhZGdlUG9zaXRpb24nLF0gfV0sXG4gICAgY29udGVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0QmFkZ2UnLF0gfV0sXG4gICAgZGVzY3JpcHRpb246IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21hdEJhZGdlRGVzY3JpcHRpb24nLF0gfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0QmFkZ2VTaXplJyxdIH1dLFxuICAgIGhpZGRlbjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbWF0QmFkZ2VIaWRkZW4nLF0gfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0QmFkZ2UubmdBY2NlcHRJbnB1dFR5cGVfZGlzYWJsZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdEJhZGdlLm5nQWNjZXB0SW5wdXRUeXBlX2hpZGRlbjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0QmFkZ2UubmdBY2NlcHRJbnB1dFR5cGVfb3ZlcmxhcDtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBiYWRnZSBoYXMgYW55IGNvbnRlbnQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0QmFkZ2UucHJvdG90eXBlLl9oYXNDb250ZW50O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0QmFkZ2UucHJvdG90eXBlLl9jb2xvcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5fb3ZlcmxhcDtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgYmFkZ2Ugc2hvdWxkIHJlc2lkZS5cbiAgICAgKiBBY2NlcHRzIGFueSBjb21iaW5hdGlvbiBvZiAnYWJvdmUnfCdiZWxvdycgYW5kICdiZWZvcmUnfCdhZnRlcidcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRCYWRnZS5wcm90b3R5cGUucG9zaXRpb247XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgZm9yIHRoZSBiYWRnZVxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5jb250ZW50O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0QmFkZ2UucHJvdG90eXBlLl9kZXNjcmlwdGlvbjtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBiYWRnZS4gQ2FuIGJlICdzbWFsbCcsICdtZWRpdW0nLCBvciAnbGFyZ2UnLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5zaXplO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0QmFkZ2UucHJvdG90eXBlLl9oaWRkZW47XG4gICAgLyoqXG4gICAgICogVW5pcXVlIGlkIGZvciB0aGUgYmFkZ2VcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRCYWRnZS5wcm90b3R5cGUuX2lkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWF0QmFkZ2UucHJvdG90eXBlLl9iYWRnZUVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRCYWRnZS5wcm90b3R5cGUuX25nWm9uZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5fZWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5fYXJpYURlc2NyaWJlcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdEJhZGdlLnByb3RvdHlwZS5fcmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNYXRCYWRnZS5wcm90b3R5cGUuX2FuaW1hdGlvbk1vZGU7XG59XG4iXX0=