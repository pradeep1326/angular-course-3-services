/**
 * @fileoverview added by tsickle
 * Generated from: src/material/core/gestures/gesture-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, InjectionToken, Inject, Optional } from '@angular/core';
import { HammerGestureConfig } from '@angular/platform-browser';
import { MatCommonModule } from '../common-behaviors/common-module';
/**
 * Injection token that can be used to provide options to the Hammerjs instance.
 * More info at http://hammerjs.github.io/api/.
 * @deprecated No longer being used. To be removed.
 * \@breaking-change 10.0.0
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
export const MAT_HAMMER_OPTIONS = new InjectionToken('MAT_HAMMER_OPTIONS');
/** @type {?} */
const ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES = [
    'longpress',
    'slide',
    'slidestart',
    'slideend',
    'slideright',
    'slideleft'
];
const ɵ0 = /**
 * @return {?}
 */
() => { }, ɵ1 = /**
 * @return {?}
 */
() => { };
/**
 * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not
 * been loaded on the page.
 * @type {?}
 */
const noopHammerInstance = {
    on: (ɵ0),
    off: (ɵ1),
};
/**
 * Adjusts configuration of our gesture library, Hammer.
 * @deprecated No longer being used. To be removed.
 * \@breaking-change 10.0.0
 */
export class GestureConfig extends HammerGestureConfig {
    /**
     * @param {?=} _hammerOptions
     * @param {?=} _commonModule
     */
    constructor(_hammerOptions, _commonModule) {
        super();
        this._hammerOptions = _hammerOptions;
        /**
         * List of new event names to add to the gesture support list
         */
        this.events = ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES;
    }
    /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param {?} element Element to which to assign the new HammerJS gestures.
     * @return {?} Newly-created HammerJS instance.
     */
    buildHammer(element) {
        /** @type {?} */
        const hammer = typeof window !== 'undefined' ? ((/** @type {?} */ (window))).Hammer : null;
        if (!hammer) {
            // If HammerJS is not loaded here, return the noop HammerInstance. This is necessary to
            // ensure that omitting HammerJS completely will not cause any errors while *also* supporting
            // the lazy-loading of HammerJS via the HAMMER_LOADER token introduced in Angular 6.1.
            // Because we can't depend on HAMMER_LOADER's existance until 7.0, we have to always set
            // `this.events` to the set we support, instead of conditionally setting it to `[]` if
            // `HAMMER_LOADER` is present (and then throwing an Error here if `window.Hammer` is
            // undefined).
            // @breaking-change 8.0.0
            return noopHammerInstance;
        }
        /** @type {?} */
        const mc = new hammer(element, this._hammerOptions || undefined);
        // Default Hammer Recognizers.
        /** @type {?} */
        const pan = new hammer.Pan();
        /** @type {?} */
        const swipe = new hammer.Swipe();
        /** @type {?} */
        const press = new hammer.Press();
        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
        // Otherwise the previous `recognizeWith` will be dropped.
        // TODO: Confirm threshold numbers with Material Design UX Team
        /** @type {?} */
        const slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
        /** @type {?} */
        const longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
        // Overwrite the default `pan` event to use the swipe event.
        pan.recognizeWith(swipe);
        // Since the slide event threshold is set to zero, the slide recognizer can fire and
        // accidentally reset the longpress recognizer. In order to make sure that the two
        // recognizers can run simultaneously but don't affect each other, we allow the slide
        // recognizer to recognize while a longpress is being processed.
        // See: https://github.com/hammerjs/hammer.js/blob/master/src/manager.js#L123-L124
        longpress.recognizeWith(slide);
        // Add customized gestures to Hammer manager
        mc.add([swipe, press, pan, slide, longpress]);
        return (/** @type {?} */ (mc));
    }
    /**
     * Creates a new recognizer, without affecting the default recognizers of HammerJS
     * @private
     * @param {?} base
     * @param {?} options
     * @param {...?} inheritances
     * @return {?}
     */
    _createRecognizer(base, options, ...inheritances) {
        /** @type {?} */
        let recognizer = new ((/** @type {?} */ (base.constructor)))(options);
        inheritances.push(base);
        inheritances.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => recognizer.recognizeWith(item)));
        return recognizer;
    }
}
GestureConfig.ɵfac = function GestureConfig_Factory(t) { return new (t || GestureConfig)(ɵngcc0.ɵɵinject(MAT_HAMMER_OPTIONS, 8), ɵngcc0.ɵɵinject(MatCommonModule, 8)); };
GestureConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GestureConfig, factory: GestureConfig.ɵfac });
/** @nocollapse */
GestureConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_HAMMER_OPTIONS,] }] },
    { type: MatCommonModule, decorators: [{ type: Optional }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GestureConfig, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_HAMMER_OPTIONS]
            }] }, { type: MatCommonModule, decorators: [{
                type: Optional
            }] }]; }, null); })();
if (false) {
    /**
     * List of new event names to add to the gesture support list
     * @type {?}
     */
    GestureConfig.prototype.events;
    /**
     * @type {?}
     * @private
     */
    GestureConfig.prototype._hammerOptions;
}
export { ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtMjAxNS9jb3JlL2dlc3R1cmVzL2dlc3R1cmUtY29uZmlnLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0hDLHNHQUdDOzs7Ozs7Ozs7Ozs7Ozs7a0NBS0EiLCJmaWxlIjoiZ2VzdHVyZS1jb25maWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHNyYy9tYXRlcmlhbC9jb3JlL2dlc3R1cmVzL2dlc3R1cmUtY29uZmlnLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVDb25maWcgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IE1hdENvbW1vbk1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi1iZWhhdmlvcnMvY29tbW9uLW1vZHVsZSc7XG4vKipcbiAqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgb3B0aW9ucyB0byB0aGUgSGFtbWVyanMgaW5zdGFuY2UuXG4gKiBNb3JlIGluZm8gYXQgaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvLlxuICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIGJlaW5nIHVzZWQuIFRvIGJlIHJlbW92ZWQuXG4gKiBcXEBicmVha2luZy1jaGFuZ2UgMTAuMC4wXG4gKiBAdHlwZSB7P31cbiAqL1xuZXhwb3J0IGNvbnN0IE1BVF9IQU1NRVJfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTUFUX0hBTU1FUl9PUFRJT05TJyk7XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBBTkdVTEFSX01BVEVSSUFMX1NVUFBPUlRFRF9IQU1NRVJfR0VTVFVSRVMgPSBbXG4gICAgJ2xvbmdwcmVzcycsXG4gICAgJ3NsaWRlJyxcbiAgICAnc2xpZGVzdGFydCcsXG4gICAgJ3NsaWRlZW5kJyxcbiAgICAnc2xpZGVyaWdodCcsXG4gICAgJ3NsaWRlbGVmdCdcbl07XG5jb25zdCDJtTAgPSAvKipcbiAqIEByZXR1cm4gez99XG4gKi9cbigpID0+IHsgfSwgybUxID0gLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG4oKSA9PiB7IH07XG4vKipcbiAqIEZha2UgSGFtbWVySW5zdGFuY2UgdGhhdCBpcyB1c2VkIHdoZW4gYSBIYW1tZXIgaW5zdGFuY2UgaXMgcmVxdWVzdGVkIHdoZW4gSGFtbWVySlMgaGFzIG5vdFxuICogYmVlbiBsb2FkZWQgb24gdGhlIHBhZ2UuXG4gKiBAdHlwZSB7P31cbiAqL1xuY29uc3Qgbm9vcEhhbW1lckluc3RhbmNlID0ge1xuICAgIG9uOiAoybUwKSxcbiAgICBvZmY6ICjJtTEpLFxufTtcbi8qKlxuICogQWRqdXN0cyBjb25maWd1cmF0aW9uIG9mIG91ciBnZXN0dXJlIGxpYnJhcnksIEhhbW1lci5cbiAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciBiZWluZyB1c2VkLiBUbyBiZSByZW1vdmVkLlxuICogXFxAYnJlYWtpbmctY2hhbmdlIDEwLjAuMFxuICovXG5leHBvcnQgY2xhc3MgR2VzdHVyZUNvbmZpZyBleHRlbmRzIEhhbW1lckdlc3R1cmVDb25maWcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9oYW1tZXJPcHRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gX2NvbW1vbk1vZHVsZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9oYW1tZXJPcHRpb25zLCBfY29tbW9uTW9kdWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2hhbW1lck9wdGlvbnMgPSBfaGFtbWVyT3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgbmV3IGV2ZW50IG5hbWVzIHRvIGFkZCB0byB0aGUgZ2VzdHVyZSBzdXBwb3J0IGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0gQU5HVUxBUl9NQVRFUklBTF9TVVBQT1JURURfSEFNTUVSX0dFU1RVUkVTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgSGFtbWVyIGluc3RhbmNlIG1hbnVhbGx5IHRvIGFkZCBjdXN0b20gcmVjb2duaXplcnMgdGhhdCBtYXRjaCB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAgICpcbiAgICAgKiBPdXIgZ2VzdHVyZSBuYW1lcyBjb21lIGZyb20gdGhlIE1hdGVyaWFsIERlc2lnbiBnZXN0dXJlcyBzcGVjOlxuICAgICAqIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduLyNnZXN0dXJlcy10b3VjaC1tZWNoYW5pY3NcbiAgICAgKlxuICAgICAqIE1vcmUgaW5mb3JtYXRpb24gb24gZGVmYXVsdCByZWNvZ25pemVycyBjYW4gYmUgZm91bmQgaW4gSGFtbWVyIGRvY3M6XG4gICAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXBhbi9cbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcHJlc3MvXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhc3NpZ24gdGhlIG5ldyBIYW1tZXJKUyBnZXN0dXJlcy5cbiAgICAgKiBAcmV0dXJuIHs/fSBOZXdseS1jcmVhdGVkIEhhbW1lckpTIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGJ1aWxkSGFtbWVyKGVsZW1lbnQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBoYW1tZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/ICgoLyoqIEB0eXBlIHs/fSAqLyAod2luZG93KSkpLkhhbW1lciA6IG51bGw7XG4gICAgICAgIGlmICghaGFtbWVyKSB7XG4gICAgICAgICAgICAvLyBJZiBIYW1tZXJKUyBpcyBub3QgbG9hZGVkIGhlcmUsIHJldHVybiB0aGUgbm9vcCBIYW1tZXJJbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IG9taXR0aW5nIEhhbW1lckpTIGNvbXBsZXRlbHkgd2lsbCBub3QgY2F1c2UgYW55IGVycm9ycyB3aGlsZSAqYWxzbyogc3VwcG9ydGluZ1xuICAgICAgICAgICAgLy8gdGhlIGxhenktbG9hZGluZyBvZiBIYW1tZXJKUyB2aWEgdGhlIEhBTU1FUl9MT0FERVIgdG9rZW4gaW50cm9kdWNlZCBpbiBBbmd1bGFyIDYuMS5cbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuJ3QgZGVwZW5kIG9uIEhBTU1FUl9MT0FERVIncyBleGlzdGFuY2UgdW50aWwgNy4wLCB3ZSBoYXZlIHRvIGFsd2F5cyBzZXRcbiAgICAgICAgICAgIC8vIGB0aGlzLmV2ZW50c2AgdG8gdGhlIHNldCB3ZSBzdXBwb3J0LCBpbnN0ZWFkIG9mIGNvbmRpdGlvbmFsbHkgc2V0dGluZyBpdCB0byBgW11gIGlmXG4gICAgICAgICAgICAvLyBgSEFNTUVSX0xPQURFUmAgaXMgcHJlc2VudCAoYW5kIHRoZW4gdGhyb3dpbmcgYW4gRXJyb3IgaGVyZSBpZiBgd2luZG93LkhhbW1lcmAgaXNcbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCkuXG4gICAgICAgICAgICAvLyBAYnJlYWtpbmctY2hhbmdlIDguMC4wXG4gICAgICAgICAgICByZXR1cm4gbm9vcEhhbW1lckluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbWMgPSBuZXcgaGFtbWVyKGVsZW1lbnQsIHRoaXMuX2hhbW1lck9wdGlvbnMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gRGVmYXVsdCBIYW1tZXIgUmVjb2duaXplcnMuXG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgcGFuID0gbmV3IGhhbW1lci5QYW4oKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBzd2lwZSA9IG5ldyBoYW1tZXIuU3dpcGUoKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBwcmVzcyA9IG5ldyBoYW1tZXIuUHJlc3MoKTtcbiAgICAgICAgLy8gTm90aWNlIHRoYXQgYSBIYW1tZXJKUyByZWNvZ25pemVyIGNhbiBvbmx5IGRlcGVuZCBvbiBvbmUgb3RoZXIgcmVjb2duaXplciBvbmNlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHByZXZpb3VzIGByZWNvZ25pemVXaXRoYCB3aWxsIGJlIGRyb3BwZWQuXG4gICAgICAgIC8vIFRPRE86IENvbmZpcm0gdGhyZXNob2xkIG51bWJlcnMgd2l0aCBNYXRlcmlhbCBEZXNpZ24gVVggVGVhbVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwYW4sIHsgZXZlbnQ6ICdzbGlkZScsIHRocmVzaG9sZDogMCB9LCBzd2lwZSk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgbG9uZ3ByZXNzID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwcmVzcywgeyBldmVudDogJ2xvbmdwcmVzcycsIHRpbWU6IDUwMCB9KTtcbiAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBkZWZhdWx0IGBwYW5gIGV2ZW50IHRvIHVzZSB0aGUgc3dpcGUgZXZlbnQuXG4gICAgICAgIHBhbi5yZWNvZ25pemVXaXRoKHN3aXBlKTtcbiAgICAgICAgLy8gU2luY2UgdGhlIHNsaWRlIGV2ZW50IHRocmVzaG9sZCBpcyBzZXQgdG8gemVybywgdGhlIHNsaWRlIHJlY29nbml6ZXIgY2FuIGZpcmUgYW5kXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSByZXNldCB0aGUgbG9uZ3ByZXNzIHJlY29nbml6ZXIuIEluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB0d29cbiAgICAgICAgLy8gcmVjb2duaXplcnMgY2FuIHJ1biBzaW11bHRhbmVvdXNseSBidXQgZG9uJ3QgYWZmZWN0IGVhY2ggb3RoZXIsIHdlIGFsbG93IHRoZSBzbGlkZVxuICAgICAgICAvLyByZWNvZ25pemVyIHRvIHJlY29nbml6ZSB3aGlsZSBhIGxvbmdwcmVzcyBpcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2hhbW1lcmpzL2hhbW1lci5qcy9ibG9iL21hc3Rlci9zcmMvbWFuYWdlci5qcyNMMTIzLUwxMjRcbiAgICAgICAgbG9uZ3ByZXNzLnJlY29nbml6ZVdpdGgoc2xpZGUpO1xuICAgICAgICAvLyBBZGQgY3VzdG9taXplZCBnZXN0dXJlcyB0byBIYW1tZXIgbWFuYWdlclxuICAgICAgICBtYy5hZGQoW3N3aXBlLCBwcmVzcywgcGFuLCBzbGlkZSwgbG9uZ3ByZXNzXSk7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHs/fSAqLyAobWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZWNvZ25pemVyLCB3aXRob3V0IGFmZmVjdGluZyB0aGUgZGVmYXVsdCByZWNvZ25pemVycyBvZiBIYW1tZXJKU1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHsuLi4/fSBpbmhlcml0YW5jZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jcmVhdGVSZWNvZ25pemVyKGJhc2UsIG9wdGlvbnMsIC4uLmluaGVyaXRhbmNlcykge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCByZWNvZ25pemVyID0gbmV3ICgoLyoqIEB0eXBlIHs/fSAqLyAoYmFzZS5jb25zdHJ1Y3RvcikpKShvcHRpb25zKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5mb3JFYWNoKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpdGVtXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtID0+IHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtKSkpO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9XG59XG5HZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkdlc3R1cmVDb25maWcuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFUX0hBTU1FUl9PUFRJT05TLF0gfV0gfSxcbiAgICB7IHR5cGU6IE1hdENvbW1vbk1vZHVsZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuXTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgbmV3IGV2ZW50IG5hbWVzIHRvIGFkZCB0byB0aGUgZ2VzdHVyZSBzdXBwb3J0IGxpc3RcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5ldmVudHM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5faGFtbWVyT3B0aW9ucztcbn1cbmV4cG9ydCB7IMm1MCwgybUxIH07XG4iXX0=