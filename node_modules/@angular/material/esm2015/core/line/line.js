/**
 * @fileoverview added by tsickle
 * Generated from: src/material/core/line/line.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModule, Directive, } from '@angular/core';
import { startWith } from 'rxjs/operators';
import { MatCommonModule } from '../common-behaviors/common-module';
/**
 * Shared directive to count lines inside a text area, such as a list item.
 * Line elements can be extracted with a \@ContentChildren(MatLine) query, then
 * counted by checking the query list's length.
 */
import * as ɵngcc0 from '@angular/core';
export class MatLine {
}
MatLine.ɵfac = function MatLine_Factory(t) { return new (t || MatLine)(); };
MatLine.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatLine, selectors: [["", "mat-line", ""], ["", "matLine", ""]], hostAttrs: [1, "mat-line"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatLine, [{
        type: Directive,
        args: [{
                selector: '[mat-line], [matLine]',
                host: { 'class': 'mat-line' }
            }]
    }], null, null); })();
/**
 * Helper that takes a query list of lines and sets the correct class on the host.
 * \@docs-private
 * @param {?} lines
 * @param {?} element
 * @return {?}
 */
export function setLines(lines, element) {
    // Note: doesn't need to unsubscribe, because `changes`
    // gets completed by Angular when the view is destroyed.
    lines.changes.pipe(startWith(lines)).subscribe((/**
     * @param {?} __0
     * @return {?}
     */
    ({ length }) => {
        setClass(element, 'mat-2-line', false);
        setClass(element, 'mat-3-line', false);
        setClass(element, 'mat-multi-line', false);
        if (length === 2 || length === 3) {
            setClass(element, `mat-${length}-line`, true);
        }
        else if (length > 3) {
            setClass(element, `mat-multi-line`, true);
        }
    }));
}
/**
 * Adds or removes a class from an element.
 * @param {?} element
 * @param {?} className
 * @param {?} isAdd
 * @return {?}
 */
function setClass(element, className, isAdd) {
    /** @type {?} */
    const classList = element.nativeElement.classList;
    isAdd ? classList.add(className) : classList.remove(className);
}
/**
 * Helper that takes a query list of lines and sets the correct class on the host.
 * \@docs-private
 * @deprecated Use `setLines` instead.
 * \@breaking-change 8.0.0
 */
export class MatLineSetter {
    /**
     * @param {?} lines
     * @param {?} element
     */
    constructor(lines, element) {
        setLines(lines, element);
    }
}
export class MatLineModule {
}
MatLineModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatLineModule });
MatLineModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatLineModule_Factory(t) { return new (t || MatLineModule)(); }, imports: [[MatCommonModule],
        MatCommonModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatLineModule, { declarations: function () { return [MatLine]; }, imports: function () { return [MatCommonModule]; }, exports: function () { return [MatLine,
        MatCommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatLineModule, [{
        type: NgModule,
        args: [{
                imports: [MatCommonModule],
                exports: [MatLine, MatCommonModule],
                declarations: [MatLine]
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtMjAxNS9jb3JlL2xpbmUvbGluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Q0FDQzs7Ozs7OzswQkFNQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVERDs7Ozs7Ozs7OzswQkFPQyIsImZpbGUiOiJsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBzcmMvbWF0ZXJpYWwvY29yZS9saW5lL2xpbmUudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSwgRGlyZWN0aXZlLCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTWF0Q29tbW9uTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uLWJlaGF2aW9ycy9jb21tb24tbW9kdWxlJztcbi8qKlxuICogU2hhcmVkIGRpcmVjdGl2ZSB0byBjb3VudCBsaW5lcyBpbnNpZGUgYSB0ZXh0IGFyZWEsIHN1Y2ggYXMgYSBsaXN0IGl0ZW0uXG4gKiBMaW5lIGVsZW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBhIFxcQENvbnRlbnRDaGlsZHJlbihNYXRMaW5lKSBxdWVyeSwgdGhlblxuICogY291bnRlZCBieSBjaGVja2luZyB0aGUgcXVlcnkgbGlzdCdzIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hdExpbmUge1xufVxuTWF0TGluZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21hdC1saW5lXSwgW21hdExpbmVdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGluZScgfVxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKipcbiAqIEhlbHBlciB0aGF0IHRha2VzIGEgcXVlcnkgbGlzdCBvZiBsaW5lcyBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzcyBvbiB0aGUgaG9zdC5cbiAqIFxcQGRvY3MtcHJpdmF0ZVxuICogQHBhcmFtIHs/fSBsaW5lc1xuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TGluZXMobGluZXMsIGVsZW1lbnQpIHtcbiAgICAvLyBOb3RlOiBkb2Vzbid0IG5lZWQgdG8gdW5zdWJzY3JpYmUsIGJlY2F1c2UgYGNoYW5nZXNgXG4gICAgLy8gZ2V0cyBjb21wbGV0ZWQgYnkgQW5ndWxhciB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICBsaW5lcy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKGxpbmVzKSkuc3Vic2NyaWJlKCgvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgKHsgbGVuZ3RoIH0pID0+IHtcbiAgICAgICAgc2V0Q2xhc3MoZWxlbWVudCwgJ21hdC0yLWxpbmUnLCBmYWxzZSk7XG4gICAgICAgIHNldENsYXNzKGVsZW1lbnQsICdtYXQtMy1saW5lJywgZmFsc2UpO1xuICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCAnbWF0LW11bHRpLWxpbmUnLCBmYWxzZSk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgfHwgbGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBgbWF0LSR7bGVuZ3RofS1saW5lYCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID4gMykge1xuICAgICAgICAgICAgc2V0Q2xhc3MoZWxlbWVudCwgYG1hdC1tdWx0aS1saW5lYCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG59XG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGZyb20gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7P30gZWxlbWVudFxuICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAqIEBwYXJhbSB7P30gaXNBZGRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNldENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgY29uc3QgY2xhc3NMaXN0ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdDtcbiAgICBpc0FkZCA/IGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSA6IGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbn1cbi8qKlxuICogSGVscGVyIHRoYXQgdGFrZXMgYSBxdWVyeSBsaXN0IG9mIGxpbmVzIGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzIG9uIHRoZSBob3N0LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHNldExpbmVzYCBpbnN0ZWFkLlxuICogXFxAYnJlYWtpbmctY2hhbmdlIDguMC4wXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRMaW5lU2V0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGxpbmVzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGluZXMsIGVsZW1lbnQpIHtcbiAgICAgICAgc2V0TGluZXMobGluZXMsIGVsZW1lbnQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXRMaW5lTW9kdWxlIHtcbn1cbk1hdExpbmVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNYXRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYXRMaW5lLCBNYXRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdExpbmVdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG4iXX0=