/**
 * @fileoverview added by tsickle
 * Generated from: src/material/tabs/tab-nav-bar/tab-nav-bar.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directionality } from '@angular/cdk/bidi';
import { Platform } from '@angular/cdk/platform';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, forwardRef, Inject, Input, NgZone, Optional, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';
import { MAT_RIPPLE_GLOBAL_OPTIONS, mixinDisabled, mixinDisableRipple, mixinTabIndex, RippleRenderer, } from '@angular/material/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { FocusMonitor } from '@angular/cdk/a11y';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { MatInkBar } from '../ink-bar';
import { MatPaginatedTabHeader } from '../paginated-tab-header';
import { startWith, takeUntil } from 'rxjs/operators';
/**
 * Base class with all of the `MatTabNav` functionality.
 * \@docs-private
 * @abstract
 */
// tslint:disable-next-line:class-name
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/bidi';
import * as ɵngcc2 from '@angular/cdk/scrolling';
import * as ɵngcc3 from '@angular/cdk/platform';
import * as ɵngcc4 from '@angular/material/core';
import * as ɵngcc5 from '@angular/cdk/observers';
import * as ɵngcc6 from '../ink-bar';
import * as ɵngcc7 from '@angular/cdk/a11y';

const _c0 = ["tabListContainer"];
const _c1 = ["tabList"];
const _c2 = ["nextPaginator"];
const _c3 = ["previousPaginator"];
const _c4 = ["mat-tab-nav-bar", ""];
const _c5 = ["*"];
export class _MatTabNavBase extends MatPaginatedTabHeader {
    /**
     * @param {?} elementRef
     * @param {?} dir
     * @param {?} ngZone
     * @param {?} changeDetectorRef
     * @param {?} viewportRuler
     * @param {?=} platform
     * @param {?=} animationMode
     */
    constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
    /**
     * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
     */
    platform, animationMode) {
        super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);
        this._disableRipple = false;
        /**
         * Theme color of the nav bar.
         */
        this.color = 'primary';
    }
    /**
     * Background color of the tab nav.
     * @return {?}
     */
    get backgroundColor() { return this._backgroundColor; }
    /**
     * @param {?} value
     * @return {?}
     */
    set backgroundColor(value) {
        /** @type {?} */
        const classList = this._elementRef.nativeElement.classList;
        classList.remove(`mat-background-${this.backgroundColor}`);
        if (value) {
            classList.add(`mat-background-${value}`);
        }
        this._backgroundColor = value;
    }
    /**
     * Whether the ripple effect is disabled or not.
     * @return {?}
     */
    get disableRipple() { return this._disableRipple; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableRipple(value) { this._disableRipple = coerceBooleanProperty(value); }
    /**
     * @protected
     * @return {?}
     */
    _itemSelected() {
        // noop
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // We need this to run before the `changes` subscription in parent to ensure that the
        // selectedIndex is up-to-date by the time the super class starts looking for it.
        this._items.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe((/**
         * @return {?}
         */
        () => {
            this.updateActiveLink();
        }));
        super.ngAfterContentInit();
    }
    /**
     * Notifies the component that the active link has been changed.
     * \@breaking-change 8.0.0 `element` parameter to be removed.
     * @param {?=} _element
     * @return {?}
     */
    updateActiveLink(_element) {
        if (!this._items) {
            return;
        }
        /** @type {?} */
        const items = this._items.toArray();
        for (let i = 0; i < items.length; i++) {
            if (items[i].active) {
                this.selectedIndex = i;
                this._changeDetectorRef.markForCheck();
                return;
            }
        }
        // The ink bar should hide itself if no items are active.
        this.selectedIndex = -1;
        this._inkBar.hide();
    }
}
_MatTabNavBase.ɵfac = function _MatTabNavBase_Factory(t) { return new (t || _MatTabNavBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
_MatTabNavBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: _MatTabNavBase, inputs: { color: "color", backgroundColor: "backgroundColor", disableRipple: "disableRipple" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
_MatTabNavBase.ctorParameters = () => [
    { type: ElementRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ViewportRuler },
    { type: Platform, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
_MatTabNavBase.propDecorators = {
    backgroundColor: [{ type: Input }],
    disableRipple: [{ type: Input }],
    color: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(_MatTabNavBase, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Directionality, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.ViewportRuler }, { type: ɵngcc3.Platform, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { color: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * Query list of all tab links of the tab navigation.
     * @type {?}
     */
    _MatTabNavBase.prototype._items;
    /**
     * @type {?}
     * @private
     */
    _MatTabNavBase.prototype._backgroundColor;
    /**
     * @type {?}
     * @private
     */
    _MatTabNavBase.prototype._disableRipple;
    /**
     * Theme color of the nav bar.
     * @type {?}
     */
    _MatTabNavBase.prototype.color;
}
/**
 * Navigation component matching the styles of the tab group header.
 * Provides anchored navigation with animated ink bar.
 */
export class MatTabNav extends _MatTabNavBase {
    /**
     * @param {?} elementRef
     * @param {?} dir
     * @param {?} ngZone
     * @param {?} changeDetectorRef
     * @param {?} viewportRuler
     * @param {?=} platform
     * @param {?=} animationMode
     */
    constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
    /**
     * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
     */
    platform, animationMode) {
        super(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode);
    }
}
MatTabNav.ɵfac = function MatTabNav_Factory(t) { return new (t || MatTabNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
MatTabNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatTabNav, selectors: [["", "mat-tab-nav-bar", ""]], contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MatTabLink, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._items = _t);
    } }, viewQuery: function MatTabNav_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(MatInkBar, true);
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inkBar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabListContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._nextPaginator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._previousPaginator = _t.first);
    } }, hostAttrs: [1, "mat-tab-nav-bar", "mat-tab-header"], hostVars: 10, hostBindings: function MatTabNav_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-tab-header-pagination-controls-enabled", ctx._showPaginationControls)("mat-tab-header-rtl", ctx._getLayoutDirection() == "rtl")("mat-primary", ctx.color !== "warn" && ctx.color !== "accent")("mat-accent", ctx.color === "accent")("mat-warn", ctx.color === "warn");
    } }, inputs: { color: "color" }, exportAs: ["matTabNavBar", "matTabNav"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c4, ngContentSelectors: _c5, decls: 13, vars: 6, consts: [["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend"], ["previousPaginator", ""], [1, "mat-tab-header-pagination-chevron"], [1, "mat-tab-link-container", 3, "keydown"], ["tabListContainer", ""], [1, "mat-tab-list", 3, "cdkObserveContent"], ["tabList", ""], [1, "mat-tab-links"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend"], ["nextPaginator", ""]], template: function MatTabNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("click", function MatTabNav_Template_div_click_0_listener($event) { return ctx._handlePaginatorClick("before"); })("mousedown", function MatTabNav_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress("before", $event); })("touchend", function MatTabNav_Template_div_touchend_0_listener($event) { return ctx._stopInterval(); });
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3, 4);
        ɵngcc0.ɵɵlistener("keydown", function MatTabNav_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });
        ɵngcc0.ɵɵelementStart(5, "div", 5, 6);
        ɵngcc0.ɵɵlistener("cdkObserveContent", function MatTabNav_Template_div_cdkObserveContent_5_listener($event) { return ctx._onContentChanges(); });
        ɵngcc0.ɵɵelementStart(7, "div", 7);
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(9, "mat-ink-bar");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 8, 9);
        ɵngcc0.ɵɵlistener("mousedown", function MatTabNav_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress("after", $event); })("click", function MatTabNav_Template_div_click_10_listener($event) { return ctx._handlePaginatorClick("after"); })("touchend", function MatTabNav_Template_div_touchend_10_listener($event) { return ctx._stopInterval(); });
        ɵngcc0.ɵɵelement(12, "div", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollBefore);
        ɵngcc0.ɵɵproperty("matRippleDisabled", ctx._disableScrollBefore || ctx.disableRipple);
        ɵngcc0.ɵɵadvance(10);
        ɵngcc0.ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollAfter);
        ɵngcc0.ɵɵproperty("matRippleDisabled", ctx._disableScrollAfter || ctx.disableRipple);
    } }, directives: [ɵngcc4.MatRipple, ɵngcc5.CdkObserveContent, ɵngcc6.MatInkBar], styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\"\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n"], encapsulation: 2 });
/** @nocollapse */
MatTabNav.ctorParameters = () => [
    { type: ElementRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: ViewportRuler },
    { type: Platform, decorators: [{ type: Optional }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
MatTabNav.propDecorators = {
    _items: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => MatTabLink)), { descendants: true },] }],
    _inkBar: [{ type: ViewChild, args: [MatInkBar, { static: true },] }],
    _tabListContainer: [{ type: ViewChild, args: ['tabListContainer', { static: true },] }],
    _tabList: [{ type: ViewChild, args: ['tabList', { static: true },] }],
    _nextPaginator: [{ type: ViewChild, args: ['nextPaginator',] }],
    _previousPaginator: [{ type: ViewChild, args: ['previousPaginator',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTabNav, [{
        type: Component,
        args: [{
                selector: '[mat-tab-nav-bar]',
                exportAs: 'matTabNavBar, matTabNav',
                inputs: ['color'],
                template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\"\n     #previousPaginator\n     aria-hidden=\"true\"\n     mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\"\n     [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\"\n     (click)=\"_handlePaginatorClick('before')\"\n     (mousedown)=\"_handlePaginatorPress('before', $event)\"\n     (touchend)=\"_stopInterval()\">\n  <div class=\"mat-tab-header-pagination-chevron\"></div>\n</div>\n\n<div class=\"mat-tab-link-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\">\n  <div class=\"mat-tab-list\" #tabList (cdkObserveContent)=\"_onContentChanges()\">\n    <div class=\"mat-tab-links\">\n      <ng-content></ng-content>\n    </div>\n    <mat-ink-bar></mat-ink-bar>\n  </div>\n</div>\n\n<div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\"\n     #nextPaginator\n     aria-hidden=\"true\"\n     mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\"\n     [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\"\n     (mousedown)=\"_handlePaginatorPress('after', $event)\"\n     (click)=\"_handlePaginatorClick('after')\"\n     (touchend)=\"_stopInterval()\">\n  <div class=\"mat-tab-header-pagination-chevron\"></div>\n</div>\n",
                host: {
                    'class': 'mat-tab-nav-bar mat-tab-header',
                    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                    '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                    '[class.mat-primary]': 'color !== "warn" && color !== "accent"',
                    '[class.mat-accent]': 'color === "accent"',
                    '[class.mat-warn]': 'color === "warn"'
                },
                encapsulation: ViewEncapsulation.None,
                // tslint:disable-next-line:validate-decorators
                changeDetection: ChangeDetectionStrategy.Default,
                styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\"\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.Directionality, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.ViewportRuler }, { type: ɵngcc3.Platform, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { _items: [{
            type: ContentChildren,
            args: [forwardRef(( /**
                             * @return {?}
                             */() => MatTabLink)), { descendants: true }]
        }], _inkBar: [{
            type: ViewChild,
            args: [MatInkBar, { static: true }]
        }], _tabListContainer: [{
            type: ViewChild,
            args: ['tabListContainer', { static: true }]
        }], _tabList: [{
            type: ViewChild,
            args: ['tabList', { static: true }]
        }], _nextPaginator: [{
            type: ViewChild,
            args: ['nextPaginator']
        }], _previousPaginator: [{
            type: ViewChild,
            args: ['previousPaginator']
        }] }); })();
if (false) {
    /** @type {?} */
    MatTabNav.ngAcceptInputType_disableRipple;
    /** @type {?} */
    MatTabNav.prototype._items;
    /** @type {?} */
    MatTabNav.prototype._inkBar;
    /** @type {?} */
    MatTabNav.prototype._tabListContainer;
    /** @type {?} */
    MatTabNav.prototype._tabList;
    /** @type {?} */
    MatTabNav.prototype._nextPaginator;
    /** @type {?} */
    MatTabNav.prototype._previousPaginator;
}
// Boilerplate for applying mixins to MatTabLink.
class MatTabLinkMixinBase {
}
/** @type {?} */
const _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkMixinBase)));
/**
 * Base class with all of the `MatTabLink` functionality.
 */
// tslint:disable-next-line:class-name
export class _MatTabLinkBase extends _MatTabLinkMixinBase {
    /**
     * @param {?} _tabNavBar
     * @param {?} elementRef
     * @param {?} globalRippleOptions
     * @param {?} tabIndex
     * @param {?} _focusMonitor
     * @param {?=} animationMode
     */
    constructor(_tabNavBar, elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {
        super();
        this._tabNavBar = _tabNavBar;
        this.elementRef = elementRef;
        this._focusMonitor = _focusMonitor;
        /**
         * Whether the tab link is active or not.
         */
        this._isActive = false;
        this.rippleConfig = globalRippleOptions || {};
        this.tabIndex = parseInt(tabIndex) || 0;
        if (animationMode === 'NoopAnimations') {
            this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };
        }
        _focusMonitor.monitor(elementRef);
    }
    /**
     * Whether the link is active.
     * @return {?}
     */
    get active() { return this._isActive; }
    /**
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        if (value !== this._isActive) {
            this._isActive = value;
            this._tabNavBar.updateActiveLink(this.elementRef);
        }
    }
    /**
     * Whether ripples are disabled on interaction.
     * \@docs-private
     * @return {?}
     */
    get rippleDisabled() {
        return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||
            !!this.rippleConfig.disabled;
    }
    /**
     * @return {?}
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this.elementRef);
    }
}
_MatTabLinkBase.ɵfac = function _MatTabLinkBase_Factory(t) { return new (t || _MatTabLinkBase)(ɵngcc0.ɵɵdirectiveInject(_MatTabNavBase), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
_MatTabLinkBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: _MatTabLinkBase, inputs: { active: "active" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
_MatTabLinkBase.ctorParameters = () => [
    { type: _MatTabNavBase },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: FocusMonitor },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
_MatTabLinkBase.propDecorators = {
    active: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(_MatTabLinkBase, [{
        type: Directive
    }], function () { return [{ type: _MatTabNavBase }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_RIPPLE_GLOBAL_OPTIONS]
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ['tabindex']
            }] }, { type: ɵngcc7.FocusMonitor }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { active: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    _MatTabLinkBase.ngAcceptInputType_disabled;
    /** @type {?} */
    _MatTabLinkBase.ngAcceptInputType_disableRipple;
    /**
     * Whether the tab link is active or not.
     * @type {?}
     * @protected
     */
    _MatTabLinkBase.prototype._isActive;
    /**
     * Ripple configuration for ripples that are launched on pointer down. The ripple config
     * is set to the global ripple options since we don't have any configurable options for
     * the tab link ripples.
     * \@docs-private
     * @type {?}
     */
    _MatTabLinkBase.prototype.rippleConfig;
    /**
     * @type {?}
     * @private
     */
    _MatTabLinkBase.prototype._tabNavBar;
    /** @type {?} */
    _MatTabLinkBase.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    _MatTabLinkBase.prototype._focusMonitor;
}
/**
 * Link inside of a `mat-tab-nav-bar`.
 */
export class MatTabLink extends _MatTabLinkBase {
    /**
     * @param {?} tabNavBar
     * @param {?} elementRef
     * @param {?} ngZone
     * @param {?} platform
     * @param {?} globalRippleOptions
     * @param {?} tabIndex
     * @param {?} focusMonitor
     * @param {?=} animationMode
     */
    constructor(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {
        super(tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode);
        this._tabLinkRipple = new RippleRenderer(this, ngZone, elementRef, platform);
        this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this._tabLinkRipple._removeTriggerEvents();
    }
}
MatTabLink.ɵfac = function MatTabLink_Factory(t) { return new (t || MatTabLink)(ɵngcc0.ɵɵdirectiveInject(MatTabNav), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
MatTabLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatTabLink, selectors: [["", "mat-tab-link", ""], ["", "matTabLink", ""]], hostAttrs: [1, "mat-tab-link"], hostVars: 7, hostBindings: function MatTabLink_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-current", ctx.active ? "page" : null)("aria-disabled", ctx.disabled)("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵclassProp("mat-tab-disabled", ctx.disabled)("mat-tab-label-active", ctx.active);
    } }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matTabLink"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/** @nocollapse */
MatTabLink.ctorParameters = () => [
    { type: MatTabNav },
    { type: ElementRef },
    { type: NgZone },
    { type: Platform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: FocusMonitor },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTabLink, [{
        type: Directive,
        args: [{
                selector: '[mat-tab-link], [matTabLink]',
                exportAs: 'matTabLink',
                inputs: ['disabled', 'disableRipple', 'tabIndex'],
                host: {
                    'class': 'mat-tab-link',
                    '[attr.aria-current]': 'active ? "page" : null',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.tabIndex]': 'tabIndex',
                    '[class.mat-tab-disabled]': 'disabled',
                    '[class.mat-tab-label-active]': 'active'
                }
            }]
    }], function () { return [{ type: MatTabNav }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.Platform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_RIPPLE_GLOBAL_OPTIONS]
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ['tabindex']
            }] }, { type: ɵngcc7.FocusMonitor }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, null); })();
if (false) {
    /**
     * Reference to the RippleRenderer for the tab-link.
     * @type {?}
     * @private
     */
    MatTabLink.prototype._tabLinkRipple;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtMjAxNS90YWJzL3RhYi1uYXYtYmFyL3RhYi1uYXYtYmFyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEZDLHVOQUdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENELDJ6RkFvQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1RkQsdUpBR0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJERCwyS0FlQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FXQSIsImZpbGUiOiJ0YWItbmF2LWJhci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBHZW5lcmF0ZWQgZnJvbTogc3JjL21hdGVyaWFsL3RhYnMvdGFiLW5hdi1iYXIvdGFiLW5hdi1iYXIudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IFZpZXdwb3J0UnVsZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7IEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE9wdGlvbmFsLCBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgVmlld0VuY2Fwc3VsYXRpb24sIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfUklQUExFX0dMT0JBTF9PUFRJT05TLCBtaXhpbkRpc2FibGVkLCBtaXhpbkRpc2FibGVSaXBwbGUsIG1peGluVGFiSW5kZXgsIFJpcHBsZVJlbmRlcmVyLCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEFOSU1BVElPTl9NT0RVTEVfVFlQRSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBNYXRJbmtCYXIgfSBmcm9tICcuLi9pbmstYmFyJztcbmltcG9ydCB7IE1hdFBhZ2luYXRlZFRhYkhlYWRlciB9IGZyb20gJy4uL3BhZ2luYXRlZC10YWItaGVhZGVyJztcbmltcG9ydCB7IHN0YXJ0V2l0aCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuLyoqXG4gKiBCYXNlIGNsYXNzIHdpdGggYWxsIG9mIHRoZSBgTWF0VGFiTmF2YCBmdW5jdGlvbmFsaXR5LlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAYWJzdHJhY3RcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyBfTWF0VGFiTmF2QmFzZSBleHRlbmRzIE1hdFBhZ2luYXRlZFRhYkhlYWRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgKiBAcGFyYW0gez99IG5nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlRGV0ZWN0b3JSZWZcbiAgICAgKiBAcGFyYW0gez99IHZpZXdwb3J0UnVsZXJcbiAgICAgKiBAcGFyYW0gez89fSBwbGF0Zm9ybVxuICAgICAqIEBwYXJhbSB7Pz19IGFuaW1hdGlvbk1vZGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBkaXIsIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3JSZWYsIHZpZXdwb3J0UnVsZXIsIFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEBicmVha2luZy1jaGFuZ2UgOS4wLjAgYHBsYXRmb3JtYCBwYXJhbWV0ZXIgdG8gYmVjb21lIHJlcXVpcmVkLlxuICAgICAqL1xuICAgIHBsYXRmb3JtLCBhbmltYXRpb25Nb2RlKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIGNoYW5nZURldGVjdG9yUmVmLCB2aWV3cG9ydFJ1bGVyLCBkaXIsIG5nWm9uZSwgcGxhdGZvcm0sIGFuaW1hdGlvbk1vZGUpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVtZSBjb2xvciBvZiB0aGUgbmF2IGJhci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSAncHJpbWFyeSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgdGhlIHRhYiBuYXYuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgYmFja2dyb3VuZENvbG9yKCkgeyByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yOyB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IGJhY2tncm91bmRDb2xvcih2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoYG1hdC1iYWNrZ3JvdW5kLSR7dGhpcy5iYWNrZ3JvdW5kQ29sb3J9YCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChgbWF0LWJhY2tncm91bmQtJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBpcyBkaXNhYmxlZCBvciBub3QuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZVJpcHBsZSgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZVJpcHBsZSh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9pdGVtU2VsZWN0ZWQoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhpcyB0byBydW4gYmVmb3JlIHRoZSBgY2hhbmdlc2Agc3Vic2NyaXB0aW9uIGluIHBhcmVudCB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgLy8gc2VsZWN0ZWRJbmRleCBpcyB1cC10by1kYXRlIGJ5IHRoZSB0aW1lIHRoZSBzdXBlciBjbGFzcyBzdGFydHMgbG9va2luZyBmb3IgaXQuXG4gICAgICAgIHRoaXMuX2l0ZW1zLmNoYW5nZXMucGlwZShzdGFydFdpdGgobnVsbCksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVMaW5rKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgc3VwZXIubmdBZnRlckNvbnRlbnRJbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBjb21wb25lbnQgdGhhdCB0aGUgYWN0aXZlIGxpbmsgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBcXEBicmVha2luZy1jaGFuZ2UgOC4wLjAgYGVsZW1lbnRgIHBhcmFtZXRlciB0byBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7Pz19IF9lbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICB1cGRhdGVBY3RpdmVMaW5rKF9lbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGluayBiYXIgc2hvdWxkIGhpZGUgaXRzZWxmIGlmIG5vIGl0ZW1zIGFyZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9pbmtCYXIuaGlkZSgpO1xuICAgIH1cbn1cbl9NYXRUYWJOYXZCYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUgfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuX01hdFRhYk5hdkJhc2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFZpZXdwb3J0UnVsZXIgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0FOSU1BVElPTl9NT0RVTEVfVFlQRSxdIH1dIH1cbl07XG5fTWF0VGFiTmF2QmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVSaXBwbGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbG9yOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGxpc3Qgb2YgYWxsIHRhYiBsaW5rcyBvZiB0aGUgdGFiIG5hdmlnYXRpb24uXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgX01hdFRhYk5hdkJhc2UucHJvdG90eXBlLl9pdGVtcztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9NYXRUYWJOYXZCYXNlLnByb3RvdHlwZS5fYmFja2dyb3VuZENvbG9yO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX01hdFRhYk5hdkJhc2UucHJvdG90eXBlLl9kaXNhYmxlUmlwcGxlO1xuICAgIC8qKlxuICAgICAqIFRoZW1lIGNvbG9yIG9mIHRoZSBuYXYgYmFyLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIF9NYXRUYWJOYXZCYXNlLnByb3RvdHlwZS5jb2xvcjtcbn1cbi8qKlxuICogTmF2aWdhdGlvbiBjb21wb25lbnQgbWF0Y2hpbmcgdGhlIHN0eWxlcyBvZiB0aGUgdGFiIGdyb3VwIGhlYWRlci5cbiAqIFByb3ZpZGVzIGFuY2hvcmVkIG5hdmlnYXRpb24gd2l0aCBhbmltYXRlZCBpbmsgYmFyLlxuICovXG5leHBvcnQgY2xhc3MgTWF0VGFiTmF2IGV4dGVuZHMgX01hdFRhYk5hdkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZURldGVjdG9yUmVmXG4gICAgICogQHBhcmFtIHs/fSB2aWV3cG9ydFJ1bGVyXG4gICAgICogQHBhcmFtIHs/PX0gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRpb25Nb2RlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgZGlyLCBuZ1pvbmUsIGNoYW5nZURldGVjdG9yUmVmLCB2aWV3cG9ydFJ1bGVyLCBcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBAYnJlYWtpbmctY2hhbmdlIDkuMC4wIGBwbGF0Zm9ybWAgcGFyYW1ldGVyIHRvIGJlY29tZSByZXF1aXJlZC5cbiAgICAgKi9cbiAgICBwbGF0Zm9ybSwgYW5pbWF0aW9uTW9kZSkge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBkaXIsIG5nWm9uZSwgY2hhbmdlRGV0ZWN0b3JSZWYsIHZpZXdwb3J0UnVsZXIsIHBsYXRmb3JtLCBhbmltYXRpb25Nb2RlKTtcbiAgICB9XG59XG5NYXRUYWJOYXYuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXQtdGFiLW5hdi1iYXJdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21hdFRhYk5hdkJhciwgbWF0VGFiTmF2JyxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InXSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uIG1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3JlIG1hdC1lbGV2YXRpb24tejRcXFwiXFxuICAgICAjcHJldmlvdXNQYWdpbmF0b3JcXG4gICAgIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIlxcbiAgICAgbWF0LXJpcHBsZSBbbWF0UmlwcGxlRGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEJlZm9yZSB8fCBkaXNhYmxlUmlwcGxlXFxcIlxcbiAgICAgW2NsYXNzLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEJlZm9yZVxcXCJcXG4gICAgIChjbGljayk9XFxcIl9oYW5kbGVQYWdpbmF0b3JDbGljaygnYmVmb3JlJylcXFwiXFxuICAgICAobW91c2Vkb3duKT1cXFwiX2hhbmRsZVBhZ2luYXRvclByZXNzKCdiZWZvcmUnLCAkZXZlbnQpXFxcIlxcbiAgICAgKHRvdWNoZW5kKT1cXFwiX3N0b3BJbnRlcnZhbCgpXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvblxcXCI+PC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1saW5rLWNvbnRhaW5lclxcXCIgI3RhYkxpc3RDb250YWluZXIgKGtleWRvd24pPVxcXCJfaGFuZGxlS2V5ZG93bigkZXZlbnQpXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlzdFxcXCIgI3RhYkxpc3QgKGNka09ic2VydmVDb250ZW50KT1cXFwiX29uQ29udGVudENoYW5nZXMoKVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlua3NcXFwiPlxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgPC9kaXY+XFxuICAgIDxtYXQtaW5rLWJhcj48L21hdC1pbmstYmFyPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiBtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIG1hdC1lbGV2YXRpb24tejRcXFwiXFxuICAgICAjbmV4dFBhZ2luYXRvclxcbiAgICAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiXFxuICAgICBtYXQtcmlwcGxlIFttYXRSaXBwbGVEaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQWZ0ZXIgfHwgZGlzYWJsZVJpcHBsZVxcXCJcXG4gICAgIFtjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxBZnRlclxcXCJcXG4gICAgIChtb3VzZWRvd24pPVxcXCJfaGFuZGxlUGFnaW5hdG9yUHJlc3MoJ2FmdGVyJywgJGV2ZW50KVxcXCJcXG4gICAgIChjbGljayk9XFxcIl9oYW5kbGVQYWdpbmF0b3JDbGljaygnYWZ0ZXInKVxcXCJcXG4gICAgICh0b3VjaGVuZCk9XFxcIl9zdG9wSW50ZXJ2YWwoKVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PlxcbjwvZGl2PlxcblwiLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC10YWItbmF2LWJhciBtYXQtdGFiLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jb250cm9scy1lbmFibGVkXSc6ICdfc2hvd1BhZ2luYXRpb25Db250cm9scycsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1oZWFkZXItcnRsXSc6IFwiX2dldExheW91dERpcmVjdGlvbigpID09ICdydGwnXCIsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByaW1hcnldJzogJ2NvbG9yICE9PSBcIndhcm5cIiAmJiBjb2xvciAhPT0gXCJhY2NlbnRcIicsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjY2VudF0nOiAnY29sb3IgPT09IFwiYWNjZW50XCInLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC13YXJuXSc6ICdjb2xvciA9PT0gXCJ3YXJuXCInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFsaWRhdGUtZGVjb3JhdG9yc1xuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLWhlYWRlcntkaXNwbGF5OmZsZXg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjB9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb257LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6bm9uZTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjttaW4td2lkdGg6MzJweDtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OjI7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O3RvdWNoLWFjdGlvbjpub25lfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNvbnRyb2xzLWVuYWJsZWQgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb257ZGlzcGxheTpmbGV4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSwubWF0LXRhYi1oZWFkZXItcnRsIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVye3BhZGRpbmctbGVmdDo0cHh9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3JlIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb24sLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue3RyYW5zZm9ybTpyb3RhdGUoLTEzNWRlZyl9Lm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUsLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXJ7cGFkZGluZy1yaWdodDo0cHh9Lm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbiwubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb257Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoycHggMnB4IDAgMDtjb250ZW50OlxcXCJcXFwiO2hlaWdodDo4cHg7d2lkdGg6OHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVke2JveC1zaGFkb3c6bm9uZTtjdXJzb3I6ZGVmYXVsdH0ubWF0LXRhYi1saXN0e2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKX0ubWF0LXRhYi1saW5rc3tkaXNwbGF5OmZsZXh9W21hdC1hbGlnbi10YWJzPWNlbnRlcl0gLm1hdC10YWItbGlua3N7anVzdGlmeS1jb250ZW50OmNlbnRlcn1bbWF0LWFsaWduLXRhYnM9ZW5kXSAubWF0LXRhYi1saW5rc3tqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Lm1hdC1pbmstYmFye3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2hlaWdodDoycHg7dHJhbnNpdGlvbjo1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSl9Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlLm1hdC1pbmstYmFye3RyYW5zaXRpb246bm9uZTthbmltYXRpb246bm9uZX0ubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXIgLm1hdC1pbmstYmFye2JvdHRvbTphdXRvO3RvcDowfS5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC1pbmstYmFye291dGxpbmU6c29saWQgMnB4O2hlaWdodDowfS5tYXQtdGFiLWxpbmstY29udGFpbmVye2Rpc3BsYXk6ZmxleDtmbGV4LWdyb3c6MTtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDoxfS5tYXQtdGFiLWxpbmt7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDI0cHg7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O29wYWNpdHk6LjY7bWluLXdpZHRoOjE2MHB4O3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwO3ZlcnRpY2FsLWFsaWduOnRvcDt0ZXh0LWRlY29yYXRpb246bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5tYXQtdGFiLWxpbms6Zm9jdXN7b3V0bGluZTpub25lfS5tYXQtdGFiLWxpbms6Zm9jdXM6bm90KC5tYXQtdGFiLWRpc2FibGVkKXtvcGFjaXR5OjF9LmNkay1oaWdoLWNvbnRyYXN0LWFjdGl2ZSAubWF0LXRhYi1saW5rOmZvY3Vze291dGxpbmU6ZG90dGVkIDJweDtvdXRsaW5lLW9mZnNldDotMnB4fS5tYXQtdGFiLWxpbmsubWF0LXRhYi1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0uY2RrLWhpZ2gtY29udHJhc3QtYWN0aXZlIC5tYXQtdGFiLWxpbmsubWF0LXRhYi1kaXNhYmxlZHtvcGFjaXR5Oi41fS5tYXQtdGFiLWxpbmsgLm1hdC10YWItbGFiZWwtY29udGVudHtkaXNwbGF5OmlubGluZS1mbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3doaXRlLXNwYWNlOm5vd3JhcH0uY2RrLWhpZ2gtY29udHJhc3QtYWN0aXZlIC5tYXQtdGFiLWxpbmt7b3BhY2l0eToxfVttYXQtc3RyZXRjaC10YWJzXSAubWF0LXRhYi1saW5re2ZsZXgtYmFzaXM6MDtmbGV4LWdyb3c6MX0ubWF0LXRhYi1saW5rLm1hdC10YWItZGlzYWJsZWR7cG9pbnRlci1ldmVudHM6bm9uZX1AbWVkaWEobWF4LXdpZHRoOiA1OTlweCl7Lm1hdC10YWItbGlua3ttaW4td2lkdGg6NzJweH19XFxuXCJdXG4gICAgICAgICAgICB9XSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5NYXRUYWJOYXYuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBEaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFZpZXdwb3J0UnVsZXIgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0FOSU1BVElPTl9NT0RVTEVfVFlQRSxdIH1dIH1cbl07XG5NYXRUYWJOYXYucHJvcERlY29yYXRvcnMgPSB7XG4gICAgX2l0ZW1zOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtmb3J3YXJkUmVmKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICgpID0+IE1hdFRhYkxpbmspKSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgX2lua0JhcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbTWF0SW5rQmFyLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgX3RhYkxpc3RDb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd0YWJMaXN0Q29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIF90YWJMaXN0OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGFiTGlzdCcsIHsgc3RhdGljOiB0cnVlIH0sXSB9XSxcbiAgICBfbmV4dFBhZ2luYXRvcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ25leHRQYWdpbmF0b3InLF0gfV0sXG4gICAgX3ByZXZpb3VzUGFnaW5hdG9yOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsncHJldmlvdXNQYWdpbmF0b3InLF0gfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTWF0VGFiTmF2Lm5nQWNjZXB0SW5wdXRUeXBlX2Rpc2FibGVSaXBwbGU7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFRhYk5hdi5wcm90b3R5cGUuX2l0ZW1zO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBNYXRUYWJOYXYucHJvdG90eXBlLl9pbmtCYXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFRhYk5hdi5wcm90b3R5cGUuX3RhYkxpc3RDb250YWluZXI7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFRhYk5hdi5wcm90b3R5cGUuX3RhYkxpc3Q7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFRhYk5hdi5wcm90b3R5cGUuX25leHRQYWdpbmF0b3I7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE1hdFRhYk5hdi5wcm90b3R5cGUuX3ByZXZpb3VzUGFnaW5hdG9yO1xufVxuLy8gQm9pbGVycGxhdGUgZm9yIGFwcGx5aW5nIG1peGlucyB0byBNYXRUYWJMaW5rLlxuY2xhc3MgTWF0VGFiTGlua01peGluQmFzZSB7XG59XG4vKiogQHR5cGUgez99ICovXG5jb25zdCBfTWF0VGFiTGlua01peGluQmFzZSA9IG1peGluVGFiSW5kZXgobWl4aW5EaXNhYmxlUmlwcGxlKG1peGluRGlzYWJsZWQoTWF0VGFiTGlua01peGluQmFzZSkpKTtcbi8qKlxuICogQmFzZSBjbGFzcyB3aXRoIGFsbCBvZiB0aGUgYE1hdFRhYkxpbmtgIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG5leHBvcnQgY2xhc3MgX01hdFRhYkxpbmtCYXNlIGV4dGVuZHMgX01hdFRhYkxpbmtNaXhpbkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX3RhYk5hdkJhclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSB7P30gZ2xvYmFsUmlwcGxlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7P30gdGFiSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IF9mb2N1c01vbml0b3JcbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRpb25Nb2RlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX3RhYk5hdkJhciwgZWxlbWVudFJlZiwgZ2xvYmFsUmlwcGxlT3B0aW9ucywgdGFiSW5kZXgsIF9mb2N1c01vbml0b3IsIGFuaW1hdGlvbk1vZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGFiTmF2QmFyID0gX3RhYk5hdkJhcjtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yID0gX2ZvY3VzTW9uaXRvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHRhYiBsaW5rIGlzIGFjdGl2ZSBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJpcHBsZUNvbmZpZyA9IGdsb2JhbFJpcHBsZU9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMudGFiSW5kZXggPSBwYXJzZUludCh0YWJJbmRleCkgfHwgMDtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk1vZGUgPT09ICdOb29wQW5pbWF0aW9ucycpIHtcbiAgICAgICAgICAgIHRoaXMucmlwcGxlQ29uZmlnLmFuaW1hdGlvbiA9IHsgZW50ZXJEdXJhdGlvbjogMCwgZXhpdER1cmF0aW9uOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgX2ZvY3VzTW9uaXRvci5tb25pdG9yKGVsZW1lbnRSZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBsaW5rIGlzIGFjdGl2ZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBhY3RpdmUoKSB7IHJldHVybiB0aGlzLl9pc0FjdGl2ZTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBhY3RpdmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5faXNBY3RpdmUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RhYk5hdkJhci51cGRhdGVBY3RpdmVMaW5rKHRoaXMuZWxlbWVudFJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciByaXBwbGVzIGFyZSBkaXNhYmxlZCBvbiBpbnRlcmFjdGlvbi5cbiAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCByaXBwbGVEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuX3RhYk5hdkJhci5kaXNhYmxlUmlwcGxlIHx8XG4gICAgICAgICAgICAhIXRoaXMucmlwcGxlQ29uZmlnLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5lbGVtZW50UmVmKTtcbiAgICB9XG59XG5fTWF0VGFiTGlua0Jhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5fTWF0VGFiTGlua0Jhc2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBfTWF0VGFiTmF2QmFzZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW01BVF9SSVBQTEVfR0xPQkFMX09QVElPTlMsXSB9XSB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBBdHRyaWJ1dGUsIGFyZ3M6IFsndGFiaW5kZXgnLF0gfV0gfSxcbiAgICB7IHR5cGU6IEZvY3VzTW9uaXRvciB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0FOSU1BVElPTl9NT0RVTEVfVFlQRSxdIH1dIH1cbl07XG5fTWF0VGFiTGlua0Jhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgYWN0aXZlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbmlmIChmYWxzZSkge1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICBfTWF0VGFiTGlua0Jhc2UubmdBY2NlcHRJbnB1dFR5cGVfZGlzYWJsZWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIF9NYXRUYWJMaW5rQmFzZS5uZ0FjY2VwdElucHV0VHlwZV9kaXNhYmxlUmlwcGxlO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHRhYiBsaW5rIGlzIGFjdGl2ZSBvciBub3QuXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9NYXRUYWJMaW5rQmFzZS5wcm90b3R5cGUuX2lzQWN0aXZlO1xuICAgIC8qKlxuICAgICAqIFJpcHBsZSBjb25maWd1cmF0aW9uIGZvciByaXBwbGVzIHRoYXQgYXJlIGxhdW5jaGVkIG9uIHBvaW50ZXIgZG93bi4gVGhlIHJpcHBsZSBjb25maWdcbiAgICAgKiBpcyBzZXQgdG8gdGhlIGdsb2JhbCByaXBwbGUgb3B0aW9ucyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFueSBjb25maWd1cmFibGUgb3B0aW9ucyBmb3JcbiAgICAgKiB0aGUgdGFiIGxpbmsgcmlwcGxlcy5cbiAgICAgKiBcXEBkb2NzLXByaXZhdGVcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBfTWF0VGFiTGlua0Jhc2UucHJvdG90eXBlLnJpcHBsZUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9NYXRUYWJMaW5rQmFzZS5wcm90b3R5cGUuX3RhYk5hdkJhcjtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgX01hdFRhYkxpbmtCYXNlLnByb3RvdHlwZS5lbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX01hdFRhYkxpbmtCYXNlLnByb3RvdHlwZS5fZm9jdXNNb25pdG9yO1xufVxuLyoqXG4gKiBMaW5rIGluc2lkZSBvZiBhIGBtYXQtdGFiLW5hdi1iYXJgLlxuICovXG5leHBvcnQgY2xhc3MgTWF0VGFiTGluayBleHRlbmRzIF9NYXRUYWJMaW5rQmFzZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWJOYXZCYXJcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0gez99IG5nWm9uZVxuICAgICAqIEBwYXJhbSB7P30gcGxhdGZvcm1cbiAgICAgKiBAcGFyYW0gez99IGdsb2JhbFJpcHBsZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IHRhYkluZGV4XG4gICAgICogQHBhcmFtIHs/fSBmb2N1c01vbml0b3JcbiAgICAgKiBAcGFyYW0gez89fSBhbmltYXRpb25Nb2RlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFiTmF2QmFyLCBlbGVtZW50UmVmLCBuZ1pvbmUsIHBsYXRmb3JtLCBnbG9iYWxSaXBwbGVPcHRpb25zLCB0YWJJbmRleCwgZm9jdXNNb25pdG9yLCBhbmltYXRpb25Nb2RlKSB7XG4gICAgICAgIHN1cGVyKHRhYk5hdkJhciwgZWxlbWVudFJlZiwgZ2xvYmFsUmlwcGxlT3B0aW9ucywgdGFiSW5kZXgsIGZvY3VzTW9uaXRvciwgYW5pbWF0aW9uTW9kZSk7XG4gICAgICAgIHRoaXMuX3RhYkxpbmtSaXBwbGUgPSBuZXcgUmlwcGxlUmVuZGVyZXIodGhpcywgbmdab25lLCBlbGVtZW50UmVmLCBwbGF0Zm9ybSk7XG4gICAgICAgIHRoaXMuX3RhYkxpbmtSaXBwbGUuc2V0dXBUcmlnZ2VyRXZlbnRzKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3RhYkxpbmtSaXBwbGUuX3JlbW92ZVRyaWdnZXJFdmVudHMoKTtcbiAgICB9XG59XG5NYXRUYWJMaW5rLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0LXRhYi1saW5rXSwgW21hdFRhYkxpbmtdJyxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ21hdFRhYkxpbmsnLFxuICAgICAgICAgICAgICAgIGlucHV0czogWydkaXNhYmxlZCcsICdkaXNhYmxlUmlwcGxlJywgJ3RhYkluZGV4J10sXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXRhYi1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtY3VycmVudF0nOiAnYWN0aXZlID8gXCJwYWdlXCIgOiBudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYkluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItbGFiZWwtYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5NYXRUYWJMaW5rLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTWF0VGFiTmF2IH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFBsYXRmb3JtIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFUX1JJUFBMRV9HTE9CQUxfT1BUSU9OUyxdIH1dIH0sXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWyd0YWJpbmRleCcsXSB9XSB9LFxuICAgIHsgdHlwZTogRm9jdXNNb25pdG9yIH0sXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFLF0gfV0gfVxuXTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgUmlwcGxlUmVuZGVyZXIgZm9yIHRoZSB0YWItbGluay5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1hdFRhYkxpbmsucHJvdG90eXBlLl90YWJMaW5rUmlwcGxlO1xufVxuIl19