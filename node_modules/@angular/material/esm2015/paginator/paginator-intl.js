/**
 * @fileoverview added by tsickle
 * Generated from: src/material/paginator/paginator-intl.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injectable, Optional, SkipSelf } from '@angular/core';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * To modify the labels and text displayed, create a new instance of MatPaginatorIntl and
 * include it in a custom provider
 */
import * as ɵngcc0 from '@angular/core';
export class MatPaginatorIntl {
    constructor() {
        /**
         * Stream to emit from when labels are changed. Use this to notify components when the labels have
         * changed after initialization.
         */
        this.changes = new Subject();
        /**
         * A label for the page size selector.
         */
        this.itemsPerPageLabel = 'Items per page:';
        /**
         * A label for the button that increments the current page.
         */
        this.nextPageLabel = 'Next page';
        /**
         * A label for the button that decrements the current page.
         */
        this.previousPageLabel = 'Previous page';
        /**
         * A label for the button that moves to the first page.
         */
        this.firstPageLabel = 'First page';
        /**
         * A label for the button that moves to the last page.
         */
        this.lastPageLabel = 'Last page';
        /**
         * A label for the range of items within the current page and the length of the whole list.
         */
        this.getRangeLabel = (/**
         * @param {?} page
         * @param {?} pageSize
         * @param {?} length
         * @return {?}
         */
        (page, pageSize, length) => {
            if (length == 0 || pageSize == 0) {
                return `0 of ${length}`;
            }
            length = Math.max(length, 0);
            /** @type {?} */
            const startIndex = page * pageSize;
            // If the start index exceeds the list length, do not try and fix the end index to the end.
            /** @type {?} */
            const endIndex = startIndex < length ?
                Math.min(startIndex + pageSize, length) :
                startIndex + pageSize;
            return `${startIndex + 1} – ${endIndex} of ${length}`;
        });
    }
}
MatPaginatorIntl.ɵfac = function MatPaginatorIntl_Factory(t) { return new (t || MatPaginatorIntl)(); };
/** @nocollapse */ MatPaginatorIntl.ɵprov = i0.ɵɵdefineInjectable({ factory: function MatPaginatorIntl_Factory() { return new MatPaginatorIntl(); }, token: MatPaginatorIntl, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatPaginatorIntl, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
if (false) {
    /**
     * Stream to emit from when labels are changed. Use this to notify components when the labels have
     * changed after initialization.
     * @type {?}
     */
    MatPaginatorIntl.prototype.changes;
    /**
     * A label for the page size selector.
     * @type {?}
     */
    MatPaginatorIntl.prototype.itemsPerPageLabel;
    /**
     * A label for the button that increments the current page.
     * @type {?}
     */
    MatPaginatorIntl.prototype.nextPageLabel;
    /**
     * A label for the button that decrements the current page.
     * @type {?}
     */
    MatPaginatorIntl.prototype.previousPageLabel;
    /**
     * A label for the button that moves to the first page.
     * @type {?}
     */
    MatPaginatorIntl.prototype.firstPageLabel;
    /**
     * A label for the button that moves to the last page.
     * @type {?}
     */
    MatPaginatorIntl.prototype.lastPageLabel;
    /**
     * A label for the range of items within the current page and the length of the whole list.
     * @type {?}
     */
    MatPaginatorIntl.prototype.getRangeLabel;
}
/**
 * \@docs-private
 * @param {?} parentIntl
 * @return {?}
 */
export function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl) {
    return parentIntl || new MatPaginatorIntl();
}
/**
 * \@docs-private
 * @type {?}
 */
export const MAT_PAGINATOR_INTL_PROVIDER = {
    // If there is already an MatPaginatorIntl available, use that. Otherwise, provide a new one.
    provide: MatPaginatorIntl,
    deps: [[new Optional(), new SkipSelf(), MatPaginatorIntl]],
    useFactory: MAT_PAGINATOR_INTL_PROVIDER_FACTORY
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtMjAxNS9wYWdpbmF0b3IvcGFnaW5hdG9yLWludGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbURDLHNHQUdDOzs7OztnREFDa00iLCJmaWxlIjoicGFnaW5hdG9yLWludGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogR2VuZXJhdGVkIGZyb206IHNyYy9tYXRlcmlhbC9wYWdpbmF0b3IvcGFnaW5hdG9yLWludGwudHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxjb25zdGFudFByb3BlcnR5LGV4dHJhUmVxdWlyZSxtaXNzaW5nT3ZlcnJpZGUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCAqIGFzIGkwIGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG4vKipcbiAqIFRvIG1vZGlmeSB0aGUgbGFiZWxzIGFuZCB0ZXh0IGRpc3BsYXllZCwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIE1hdFBhZ2luYXRvckludGwgYW5kXG4gKiBpbmNsdWRlIGl0IGluIGEgY3VzdG9tIHByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRQYWdpbmF0b3JJbnRsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSB0byBlbWl0IGZyb20gd2hlbiBsYWJlbHMgYXJlIGNoYW5nZWQuIFVzZSB0aGlzIHRvIG5vdGlmeSBjb21wb25lbnRzIHdoZW4gdGhlIGxhYmVscyBoYXZlXG4gICAgICAgICAqIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlIHBhZ2Ugc2l6ZSBzZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXRlbXNQZXJQYWdlTGFiZWwgPSAnSXRlbXMgcGVyIHBhZ2U6JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBpbmNyZW1lbnRzIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHRQYWdlTGFiZWwgPSAnTmV4dCBwYWdlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBkZWNyZW1lbnRzIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpb3VzUGFnZUxhYmVsID0gJ1ByZXZpb3VzIHBhZ2UnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IG1vdmVzIHRvIHRoZSBmaXJzdCBwYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJzdFBhZ2VMYWJlbCA9ICdGaXJzdCBwYWdlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBtb3ZlcyB0byB0aGUgbGFzdCBwYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0UGFnZUxhYmVsID0gJ0xhc3QgcGFnZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxhYmVsIGZvciB0aGUgcmFuZ2Ugb2YgaXRlbXMgd2l0aGluIHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHdob2xlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFJhbmdlTGFiZWwgPSAoLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFnZVxuICAgICAgICAgKiBAcGFyYW0gez99IHBhZ2VTaXplXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGVuZ3RoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAocGFnZSwgcGFnZVNpemUsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PSAwIHx8IHBhZ2VTaXplID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYDAgb2YgJHtsZW5ndGh9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KGxlbmd0aCwgMCk7XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gcGFnZSAqIHBhZ2VTaXplO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IGluZGV4IGV4Y2VlZHMgdGhlIGxpc3QgbGVuZ3RoLCBkbyBub3QgdHJ5IGFuZCBmaXggdGhlIGVuZCBpbmRleCB0byB0aGUgZW5kLlxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4IDwgbGVuZ3RoID9cbiAgICAgICAgICAgICAgICBNYXRoLm1pbihzdGFydEluZGV4ICsgcGFnZVNpemUsIGxlbmd0aCkgOlxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggKyBwYWdlU2l6ZTtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGFydEluZGV4ICsgMX0g4oCTICR7ZW5kSW5kZXh9IG9mICR7bGVuZ3RofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk1hdFBhZ2luYXRvckludGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUsIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqLyBNYXRQYWdpbmF0b3JJbnRsLsm1cHJvdiA9IGkwLsm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gTWF0UGFnaW5hdG9ySW50bF9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE1hdFBhZ2luYXRvckludGwoKTsgfSwgdG9rZW46IE1hdFBhZ2luYXRvckludGwsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogU3RyZWFtIHRvIGVtaXQgZnJvbSB3aGVuIGxhYmVscyBhcmUgY2hhbmdlZC4gVXNlIHRoaXMgdG8gbm90aWZ5IGNvbXBvbmVudHMgd2hlbiB0aGUgbGFiZWxzIGhhdmVcbiAgICAgKiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdFBhZ2luYXRvckludGwucHJvdG90eXBlLmNoYW5nZXM7XG4gICAgLyoqXG4gICAgICogQSBsYWJlbCBmb3IgdGhlIHBhZ2Ugc2l6ZSBzZWxlY3Rvci5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRQYWdpbmF0b3JJbnRsLnByb3RvdHlwZS5pdGVtc1BlclBhZ2VMYWJlbDtcbiAgICAvKipcbiAgICAgKiBBIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgaW5jcmVtZW50cyB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE1hdFBhZ2luYXRvckludGwucHJvdG90eXBlLm5leHRQYWdlTGFiZWw7XG4gICAgLyoqXG4gICAgICogQSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IGRlY3JlbWVudHMgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBNYXRQYWdpbmF0b3JJbnRsLnByb3RvdHlwZS5wcmV2aW91c1BhZ2VMYWJlbDtcbiAgICAvKipcbiAgICAgKiBBIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRoYXQgbW92ZXMgdG8gdGhlIGZpcnN0IHBhZ2UuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UGFnaW5hdG9ySW50bC5wcm90b3R5cGUuZmlyc3RQYWdlTGFiZWw7XG4gICAgLyoqXG4gICAgICogQSBsYWJlbCBmb3IgdGhlIGJ1dHRvbiB0aGF0IG1vdmVzIHRvIHRoZSBsYXN0IHBhZ2UuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UGFnaW5hdG9ySW50bC5wcm90b3R5cGUubGFzdFBhZ2VMYWJlbDtcbiAgICAvKipcbiAgICAgKiBBIGxhYmVsIGZvciB0aGUgcmFuZ2Ugb2YgaXRlbXMgd2l0aGluIHRoZSBjdXJyZW50IHBhZ2UgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHdob2xlIGxpc3QuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTWF0UGFnaW5hdG9ySW50bC5wcm90b3R5cGUuZ2V0UmFuZ2VMYWJlbDtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAcGFyYW0gez99IHBhcmVudEludGxcbiAqIEByZXR1cm4gez99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNQVRfUEFHSU5BVE9SX0lOVExfUFJPVklERVJfRkFDVE9SWShwYXJlbnRJbnRsKSB7XG4gICAgcmV0dXJuIHBhcmVudEludGwgfHwgbmV3IE1hdFBhZ2luYXRvckludGwoKTtcbn1cbi8qKlxuICogXFxAZG9jcy1wcml2YXRlXG4gKiBAdHlwZSB7P31cbiAqL1xuZXhwb3J0IGNvbnN0IE1BVF9QQUdJTkFUT1JfSU5UTF9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE1hdFBhZ2luYXRvckludGwgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBNYXRQYWdpbmF0b3JJbnRsLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBNYXRQYWdpbmF0b3JJbnRsXV0sXG4gICAgdXNlRmFjdG9yeTogTUFUX1BBR0lOQVRPUl9JTlRMX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4iXX0=