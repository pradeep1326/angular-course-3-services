/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __extends, __read, __spread } from "tslib";
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';
import { mixinColor, mixinDisableRipple, } from '@angular/material/core';
import { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';
import { merge, Subscription } from 'rxjs';
import { startWith } from 'rxjs/operators';
import { MAT_TAB_GROUP, MatTab } from './tab';
import { MAT_TABS_CONFIG } from './tab-config';
/** Used to generate unique ID's for each tab component */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './tab-header';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './tab-label-wrapper';
import * as ɵngcc4 from '@angular/material/core';
import * as ɵngcc5 from '@angular/cdk/a11y';
import * as ɵngcc6 from '@angular/cdk/portal';
import * as ɵngcc7 from './tab-body';

var _c0 = ["tabBodyWrapper"];
var _c1 = ["tabHeader"];
function MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }
function MatTabGroup_div_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 9);
} if (rf & 2) {
    var tab_r303 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("cdkPortalOutlet", tab_r303.templateLabel);
} }
function MatTabGroup_div_2_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    var tab_r303 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵtextInterpolate(tab_r303.textLabel);
} }
function MatTabGroup_div_2_Template(rf, ctx) { if (rf & 1) {
    var _r311 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵlistener("click", function MatTabGroup_div_2_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r311); var tab_r303 = ctx.$implicit; var i_r304 = ctx.index; var ctx_r310 = ɵngcc0.ɵɵnextContext(); var _r299 = ɵngcc0.ɵɵreference(1); return ctx_r310._handleClick(tab_r303, _r299, i_r304); });
    ɵngcc0.ɵɵelementStart(1, "div", 7);
    ɵngcc0.ɵɵtemplate(2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, "ng-template", 8);
    ɵngcc0.ɵɵtemplate(3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r303 = ctx.$implicit;
    var i_r304 = ctx.index;
    var ctx_r300 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("mat-tab-label-active", ctx_r300.selectedIndex == i_r304);
    ɵngcc0.ɵɵproperty("id", ctx_r300._getTabLabelId(i_r304))("disabled", tab_r303.disabled)("matRippleDisabled", tab_r303.disabled || ctx_r300.disableRipple);
    ɵngcc0.ɵɵattribute("tabIndex", ctx_r300._getTabIndex(tab_r303, i_r304))("aria-posinset", i_r304 + 1)("aria-setsize", ctx_r300._tabs.length)("aria-controls", ctx_r300._getTabContentId(i_r304))("aria-selected", ctx_r300.selectedIndex == i_r304)("aria-label", tab_r303.ariaLabel || null)("aria-labelledby", !tab_r303.ariaLabel && tab_r303.ariaLabelledby ? tab_r303.ariaLabelledby : null);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r303.templateLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !tab_r303.templateLabel);
} }
function MatTabGroup_mat_tab_body_5_Template(rf, ctx) { if (rf & 1) {
    var _r315 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-tab-body", 10);
    ɵngcc0.ɵɵlistener("_onCentered", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r315); var ctx_r314 = ɵngcc0.ɵɵnextContext(); return ctx_r314._removeTabBodyWrapperHeight(); })("_onCentering", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r315); var ctx_r316 = ɵngcc0.ɵɵnextContext(); return ctx_r316._setTabBodyWrapperHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tab_r312 = ctx.$implicit;
    var i_r313 = ctx.index;
    var ctx_r302 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("mat-tab-body-active", ctx_r302.selectedIndex == i_r313);
    ɵngcc0.ɵɵproperty("id", ctx_r302._getTabContentId(i_r313))("content", tab_r312.content)("position", tab_r312.position)("origin", tab_r312.origin)("animationDuration", ctx_r302.animationDuration);
    ɵngcc0.ɵɵattribute("aria-labelledby", ctx_r302._getTabLabelId(i_r313));
} }
var nextId = 0;
/** A simple change event emitted on focus or selection changes. */
var MatTabChangeEvent = /** @class */ (function () {
    function MatTabChangeEvent() {
    }
    return MatTabChangeEvent;
}());
export { MatTabChangeEvent };
// Boilerplate for applying mixins to MatTabGroup.
/** @docs-private */
var MatTabGroupMixinBase = /** @class */ (function () {
    function MatTabGroupMixinBase(_elementRef) {
        this._elementRef = _elementRef;
    }
    return MatTabGroupMixinBase;
}());
var _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupMixinBase), 'primary');
/**
 * Base class with all of the `MatTabGroupBase` functionality.
 * @docs-private
 */
var _MatTabGroupBase = /** @class */ (function (_super) {
    __extends(_MatTabGroupBase, _super);
    function _MatTabGroupBase(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {
        var _this = _super.call(this, elementRef) || this;
        _this._changeDetectorRef = _changeDetectorRef;
        _this._animationMode = _animationMode;
        /** All of the tabs that belong to the group. */
        _this._tabs = new QueryList();
        /** The tab index that should be selected after the content has been checked. */
        _this._indexToSelect = 0;
        /** Snapshot of the height of the tab body wrapper before another tab is activated. */
        _this._tabBodyWrapperHeight = 0;
        /** Subscription to tabs being added/removed. */
        _this._tabsSubscription = Subscription.EMPTY;
        /** Subscription to changes in the tab labels. */
        _this._tabLabelSubscription = Subscription.EMPTY;
        _this._dynamicHeight = false;
        _this._selectedIndex = null;
        /** Position of the tab header. */
        _this.headerPosition = 'above';
        /** Output to enable support for two-way binding on `[(selectedIndex)]` */
        _this.selectedIndexChange = new EventEmitter();
        /** Event emitted when focus has changed within a tab group. */
        _this.focusChange = new EventEmitter();
        /** Event emitted when the body animation has completed */
        _this.animationDone = new EventEmitter();
        /** Event emitted when the tab selection has changed. */
        _this.selectedTabChange = new EventEmitter(true);
        _this._groupId = nextId++;
        _this.animationDuration = defaultConfig && defaultConfig.animationDuration ?
            defaultConfig.animationDuration : '500ms';
        _this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ?
            defaultConfig.disablePagination : false;
        return _this;
    }
    Object.defineProperty(_MatTabGroupBase.prototype, "dynamicHeight", {
        /** Whether the tab group should grow to the size of the active tab. */
        get: function () { return this._dynamicHeight; },
        set: function (value) { this._dynamicHeight = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_MatTabGroupBase.prototype, "selectedIndex", {
        /** The index of the active tab. */
        get: function () { return this._selectedIndex; },
        set: function (value) {
            this._indexToSelect = coerceNumberProperty(value, null);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_MatTabGroupBase.prototype, "animationDuration", {
        /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */
        get: function () { return this._animationDuration; },
        set: function (value) {
            this._animationDuration = /^\d+$/.test(value) ? value + 'ms' : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_MatTabGroupBase.prototype, "backgroundColor", {
        /** Background color of the tab group. */
        get: function () { return this._backgroundColor; },
        set: function (value) {
            var nativeElement = this._elementRef.nativeElement;
            nativeElement.classList.remove("mat-background-" + this.backgroundColor);
            if (value) {
                nativeElement.classList.add("mat-background-" + value);
            }
            this._backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be. This is where we can know exactly what position
     * each tab should be in according to the new selected index, and additionally we know how
     * a new selected tab should transition in (from the left or right).
     */
    _MatTabGroupBase.prototype.ngAfterContentChecked = function () {
        var _this = this;
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex != indexToSelect) {
            var isFirstRun_1 = this._selectedIndex == null;
            if (!isFirstRun_1) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then(function () {
                _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });
                if (!isFirstRun_1) {
                    _this.selectedIndexChange.emit(indexToSelect);
                }
            });
        }
        // Setup the position for each tab and optionally setup an origin on the next selected tab.
        this._tabs.forEach(function (tab, index) {
            tab.position = index - indexToSelect;
            // If there is already a selected tab, then set up an origin for the next selected tab
            // if it doesn't have one already.
            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
                tab.origin = indexToSelect - _this._selectedIndex;
            }
        });
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._changeDetectorRef.markForCheck();
        }
    };
    _MatTabGroupBase.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._subscribeToAllTabChanges();
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this._tabsSubscription = this._tabs.changes.subscribe(function () {
            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === _this._selectedIndex) {
                var tabs = _this._tabs.toArray();
                for (var i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        _this._indexToSelect = _this._selectedIndex = i;
                        break;
                    }
                }
            }
            _this._changeDetectorRef.markForCheck();
        });
    };
    /** Listens to changes in all of the tabs. */
    _MatTabGroupBase.prototype._subscribeToAllTabChanges = function () {
        var _this = this;
        // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching
        // some that are inside of nested tab groups. We filter them out manually by checking that
        // the closest group to the tab is the current one.
        this._allTabs.changes
            .pipe(startWith(this._allTabs))
            .subscribe(function (tabs) {
            _this._tabs.reset(tabs.filter(function (tab) {
                // @breaking-change 10.0.0 Remove null check for `_closestTabGroup`
                // once it becomes a required parameter in MatTab.
                return !tab._closestTabGroup || tab._closestTabGroup === _this;
            }));
            _this._tabs.notifyOnChanges();
        });
    };
    _MatTabGroupBase.prototype.ngOnDestroy = function () {
        this._tabs.destroy();
        this._tabsSubscription.unsubscribe();
        this._tabLabelSubscription.unsubscribe();
    };
    /** Re-aligns the ink bar to the selected tab element. */
    _MatTabGroupBase.prototype.realignInkBar = function () {
        if (this._tabHeader) {
            this._tabHeader._alignInkBarToSelectedTab();
        }
    };
    _MatTabGroupBase.prototype._focusChanged = function (index) {
        this.focusChange.emit(this._createChangeEvent(index));
    };
    _MatTabGroupBase.prototype._createChangeEvent = function (index) {
        var event = new MatTabChangeEvent;
        event.index = index;
        if (this._tabs && this._tabs.length) {
            event.tab = this._tabs.toArray()[index];
        }
        return event;
    };
    /**
     * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     */
    _MatTabGroupBase.prototype._subscribeToTabLabels = function () {
        var _this = this;
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge.apply(void 0, __spread(this._tabs.map(function (tab) { return tab._stateChanges; }))).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
    };
    /** Clamps the given index to the bounds of 0 and the tabs length. */
    _MatTabGroupBase.prototype._clampTabIndex = function (index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
    };
    /** Returns a unique id for each tab label element */
    _MatTabGroupBase.prototype._getTabLabelId = function (i) {
        return "mat-tab-label-" + this._groupId + "-" + i;
    };
    /** Returns a unique id for each tab content element */
    _MatTabGroupBase.prototype._getTabContentId = function (i) {
        return "mat-tab-content-" + this._groupId + "-" + i;
    };
    /**
     * Sets the height of the body wrapper to the height of the activating tab if dynamic
     * height property is true.
     */
    _MatTabGroupBase.prototype._setTabBodyWrapperHeight = function (tabHeight) {
        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
            return;
        }
        var wrapper = this._tabBodyWrapper.nativeElement;
        wrapper.style.height = this._tabBodyWrapperHeight + 'px';
        // This conditional forces the browser to paint the height so that
        // the animation to the new height can have an origin.
        if (this._tabBodyWrapper.nativeElement.offsetHeight) {
            wrapper.style.height = tabHeight + 'px';
        }
    };
    /** Removes the height of the tab body wrapper. */
    _MatTabGroupBase.prototype._removeTabBodyWrapperHeight = function () {
        var wrapper = this._tabBodyWrapper.nativeElement;
        this._tabBodyWrapperHeight = wrapper.clientHeight;
        wrapper.style.height = '';
        this.animationDone.emit();
    };
    /** Handle click events, setting new selected index if appropriate. */
    _MatTabGroupBase.prototype._handleClick = function (tab, tabHeader, index) {
        if (!tab.disabled) {
            this.selectedIndex = tabHeader.focusIndex = index;
        }
    };
    /** Retrieves the tabindex for the tab. */
    _MatTabGroupBase.prototype._getTabIndex = function (tab, idx) {
        if (tab.disabled) {
            return null;
        }
        return this.selectedIndex === idx ? 0 : -1;
    };
    /** @nocollapse */
    _MatTabGroupBase.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_TABS_CONFIG,] }, { type: Optional }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
    ]; };
    _MatTabGroupBase.propDecorators = {
        dynamicHeight: [{ type: Input }],
        selectedIndex: [{ type: Input }],
        headerPosition: [{ type: Input }],
        animationDuration: [{ type: Input }],
        disablePagination: [{ type: Input }],
        backgroundColor: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        focusChange: [{ type: Output }],
        animationDone: [{ type: Output }],
        selectedTabChange: [{ type: Output }]
    };
_MatTabGroupBase.ɵfac = function _MatTabGroupBase_Factory(t) { return new (t || _MatTabGroupBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_TABS_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
_MatTabGroupBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: _MatTabGroupBase, inputs: { dynamicHeight: "dynamicHeight", selectedIndex: "selectedIndex", animationDuration: "animationDuration", backgroundColor: "backgroundColor", headerPosition: "headerPosition", disablePagination: "disablePagination" }, outputs: { selectedIndexChange: "selectedIndexChange", focusChange: "focusChange", animationDone: "animationDone", selectedTabChange: "selectedTabChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(_MatTabGroupBase, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_TABS_CONFIG]
            }, {
                type: Optional
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { dynamicHeight: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], animationDuration: [{
            type: Input
        }], backgroundColor: [{
            type: Input
        }], headerPosition: [{
            type: Input
        }], disablePagination: [{
            type: Input
        }], selectedIndexChange: [{
            type: Output
        }], focusChange: [{
            type: Output
        }], animationDone: [{
            type: Output
        }], selectedTabChange: [{
            type: Output
        }] }); })();
    return _MatTabGroupBase;
}(_MatTabGroupMixinBase));
export { _MatTabGroupBase };
/**
 * Material design tab-group component. Supports basic tab pairs (label + content) and includes
 * animated ink-bar, keyboard navigation, and screen reader.
 * See: https://material.io/design/components/tabs.html
 */
var MatTabGroup = /** @class */ (function (_super) {
    __extends(MatTabGroup, _super);
    function MatTabGroup(elementRef, changeDetectorRef, defaultConfig, animationMode) {
        return _super.call(this, elementRef, changeDetectorRef, defaultConfig, animationMode) || this;
    }
    /** @nocollapse */
    MatTabGroup.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: undefined, decorators: [{ type: Inject, args: [MAT_TABS_CONFIG,] }, { type: Optional }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }
    ]; };
    MatTabGroup.propDecorators = {
        _allTabs: [{ type: ContentChildren, args: [MatTab, { descendants: true },] }],
        _tabBodyWrapper: [{ type: ViewChild, args: ['tabBodyWrapper',] }],
        _tabHeader: [{ type: ViewChild, args: ['tabHeader',] }]
    };
MatTabGroup.ɵfac = function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_TABS_CONFIG, 8), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };
MatTabGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatTabGroup, selectors: [["mat-tab-group"]], contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MatTab, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._allTabs = _t);
    } }, viewQuery: function MatTabGroup_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabBodyWrapper = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabHeader = _t.first);
    } }, hostAttrs: [1, "mat-tab-group"], hostVars: 4, hostBindings: function MatTabGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-tab-group-dynamic-height", ctx.dynamicHeight)("mat-tab-group-inverted-header", ctx.headerPosition === "below");
    } }, inputs: { color: "color", disableRipple: "disableRipple" }, exportAs: ["matTabGroup"], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: MAT_TAB_GROUP,
                useExisting: MatTabGroup
            }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 7, consts: [[3, "selectedIndex", "disableRipple", "disablePagination", "indexFocused", "selectFocusedIndex"], ["tabHeader", ""], ["class", "mat-tab-label", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "disabled", "matRippleDisabled", "click", 4, "ngFor", "ngForOf"], [1, "mat-tab-body-wrapper"], ["tabBodyWrapper", ""], ["role", "tabpanel", 3, "id", "mat-tab-body-active", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf"], ["role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", 3, "id", "disabled", "matRippleDisabled", "click"], [1, "mat-tab-label-content"], [3, "ngIf"], [3, "cdkPortalOutlet"], ["role", "tabpanel", 3, "id", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering"]], template: function MatTabGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-tab-header", 0, 1);
        ɵngcc0.ɵɵlistener("indexFocused", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); })("selectFocusedIndex", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });
        ɵngcc0.ɵɵtemplate(2, MatTabGroup_div_2_Template, 4, 14, "div", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3, 4);
        ɵngcc0.ɵɵtemplate(5, MatTabGroup_mat_tab_body_5_Template, 1, 8, "mat-tab-body", 5);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("selectedIndex", ctx.selectedIndex || 0)("disableRipple", ctx.disableRipple)("disablePagination", ctx.disablePagination);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx._tabs);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx._tabs);
    } }, directives: [ɵngcc1.MatTabHeader, ɵngcc2.NgForOf, ɵngcc3.MatTabLabelWrapper, ɵngcc4.MatRipple, ɵngcc5.CdkMonitorFocus, ɵngcc2.NgIf, ɵngcc6.CdkPortalOutlet, ɵngcc7.MatTabBody], styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTabGroup, [{
        type: Component,
        args: [{
                selector: 'mat-tab-group',
                exportAs: 'matTabGroup',
                template: "<mat-tab-header #tabHeader\n               [selectedIndex]=\"selectedIndex || 0\"\n               [disableRipple]=\"disableRipple\"\n               [disablePagination]=\"disablePagination\"\n               (indexFocused)=\"_focusChanged($event)\"\n               (selectFocusedIndex)=\"selectedIndex = $event\">\n  <div class=\"mat-tab-label\" role=\"tab\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus\n       *ngFor=\"let tab of _tabs; let i = index\"\n       [id]=\"_getTabLabelId(i)\"\n       [attr.tabIndex]=\"_getTabIndex(tab, i)\"\n       [attr.aria-posinset]=\"i + 1\"\n       [attr.aria-setsize]=\"_tabs.length\"\n       [attr.aria-controls]=\"_getTabContentId(i)\"\n       [attr.aria-selected]=\"selectedIndex == i\"\n       [attr.aria-label]=\"tab.ariaLabel || null\"\n       [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\"\n       [class.mat-tab-label-active]=\"selectedIndex == i\"\n       [disabled]=\"tab.disabled\"\n       [matRippleDisabled]=\"tab.disabled || disableRipple\"\n       (click)=\"_handleClick(tab, tabHeader, i)\">\n\n\n    <div class=\"mat-tab-label-content\">\n      <!-- If there is a label template, use it. -->\n      <ng-template [ngIf]=\"tab.templateLabel\">\n        <ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template>\n      </ng-template>\n\n      <!-- If there is not a label template, fall back to the text label. -->\n      <ng-template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</ng-template>\n    </div>\n  </div>\n</mat-tab-header>\n\n<div\n  class=\"mat-tab-body-wrapper\"\n  [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\"\n  #tabBodyWrapper>\n  <mat-tab-body role=\"tabpanel\"\n               *ngFor=\"let tab of _tabs; let i = index\"\n               [id]=\"_getTabContentId(i)\"\n               [attr.aria-labelledby]=\"_getTabLabelId(i)\"\n               [class.mat-tab-body-active]=\"selectedIndex == i\"\n               [content]=\"tab.content!\"\n               [position]=\"tab.position!\"\n               [origin]=\"tab.origin\"\n               [animationDuration]=\"animationDuration\"\n               (_onCentered)=\"_removeTabBodyWrapperHeight()\"\n               (_onCentering)=\"_setTabBodyWrapperHeight($event)\">\n  </mat-tab-body>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                // tslint:disable-next-line:validate-decorators
                changeDetection: ChangeDetectionStrategy.Default,
                inputs: ['color', 'disableRipple'],
                providers: [{
                        provide: MAT_TAB_GROUP,
                        useExisting: MatTabGroup
                    }],
                host: {
                    'class': 'mat-tab-group',
                    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
                    '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"'
                },
                styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [MAT_TABS_CONFIG]
            }, {
                type: Optional
            }] }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ANIMATION_MODULE_TYPE]
            }] }]; }, { _allTabs: [{
            type: ContentChildren,
            args: [MatTab, { descendants: true }]
        }], _tabBodyWrapper: [{
            type: ViewChild,
            args: ['tabBodyWrapper']
        }], _tabHeader: [{
            type: ViewChild,
            args: ['tabHeader']
        }] }); })();
    return MatTabGroup;
}(_MatTabGroupBase));
export { MatTabGroup };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtNS90YWJzL3RhYi1ncm91cC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXVRTSxBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBbUJBOzs7Ozs7Ozs7Ozs7O0tBYUQsQUFxQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBWUEiLCJmaWxlIjoidGFiLWdyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBfX2V4dGVuZHMsIF9fcmVhZCwgX19zcHJlYWQgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSwgY29lcmNlTnVtYmVyUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkLCBWaWV3RW5jYXBzdWxhdGlvbiwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG1peGluQ29sb3IsIG1peGluRGlzYWJsZVJpcHBsZSwgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IEFOSU1BVElPTl9NT0RVTEVfVFlQRSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBtZXJnZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNQVRfVEFCX0dST1VQLCBNYXRUYWIgfSBmcm9tICcuL3RhYic7XG5pbXBvcnQgeyBNQVRfVEFCU19DT05GSUcgfSBmcm9tICcuL3RhYi1jb25maWcnO1xuLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEJ3MgZm9yIGVhY2ggdGFiIGNvbXBvbmVudCAqL1xudmFyIG5leHRJZCA9IDA7XG4vKiogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgb24gZm9jdXMgb3Igc2VsZWN0aW9uIGNoYW5nZXMuICovXG52YXIgTWF0VGFiQ2hhbmdlRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0VGFiQ2hhbmdlRXZlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNYXRUYWJDaGFuZ2VFdmVudDtcbn0oKSk7XG5leHBvcnQgeyBNYXRUYWJDaGFuZ2VFdmVudCB9O1xuLy8gQm9pbGVycGxhdGUgZm9yIGFwcGx5aW5nIG1peGlucyB0byBNYXRUYWJHcm91cC5cbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgTWF0VGFiR3JvdXBNaXhpbkJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0VGFiR3JvdXBNaXhpbkJhc2UoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgIH1cbiAgICByZXR1cm4gTWF0VGFiR3JvdXBNaXhpbkJhc2U7XG59KCkpO1xudmFyIF9NYXRUYWJHcm91cE1peGluQmFzZSA9IG1peGluQ29sb3IobWl4aW5EaXNhYmxlUmlwcGxlKE1hdFRhYkdyb3VwTWl4aW5CYXNlKSwgJ3ByaW1hcnknKTtcbi8qKlxuICogQmFzZSBjbGFzcyB3aXRoIGFsbCBvZiB0aGUgYE1hdFRhYkdyb3VwQmFzZWAgZnVuY3Rpb25hbGl0eS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIF9NYXRUYWJHcm91cEJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9NYXRUYWJHcm91cEJhc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX01hdFRhYkdyb3VwQmFzZShlbGVtZW50UmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIGRlZmF1bHRDb25maWcsIF9hbmltYXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnRSZWYpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgX3RoaXMuX2FuaW1hdGlvbk1vZGUgPSBfYW5pbWF0aW9uTW9kZTtcbiAgICAgICAgLyoqIEFsbCBvZiB0aGUgdGFicyB0aGF0IGJlbG9uZyB0byB0aGUgZ3JvdXAuICovXG4gICAgICAgIF90aGlzLl90YWJzID0gbmV3IFF1ZXJ5TGlzdCgpO1xuICAgICAgICAvKiogVGhlIHRhYiBpbmRleCB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZCBhZnRlciB0aGUgY29udGVudCBoYXMgYmVlbiBjaGVja2VkLiAqL1xuICAgICAgICBfdGhpcy5faW5kZXhUb1NlbGVjdCA9IDA7XG4gICAgICAgIC8qKiBTbmFwc2hvdCBvZiB0aGUgaGVpZ2h0IG9mIHRoZSB0YWIgYm9keSB3cmFwcGVyIGJlZm9yZSBhbm90aGVyIHRhYiBpcyBhY3RpdmF0ZWQuICovXG4gICAgICAgIF90aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCA9IDA7XG4gICAgICAgIC8qKiBTdWJzY3JpcHRpb24gdG8gdGFicyBiZWluZyBhZGRlZC9yZW1vdmVkLiAqL1xuICAgICAgICBfdGhpcy5fdGFic1N1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgLyoqIFN1YnNjcmlwdGlvbiB0byBjaGFuZ2VzIGluIHRoZSB0YWIgbGFiZWxzLiAqL1xuICAgICAgICBfdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIF90aGlzLl9keW5hbWljSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9zZWxlY3RlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSB0YWIgaGVhZGVyLiAqL1xuICAgICAgICBfdGhpcy5oZWFkZXJQb3NpdGlvbiA9ICdhYm92ZSc7XG4gICAgICAgIC8qKiBPdXRwdXQgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHR3by13YXkgYmluZGluZyBvbiBgWyhzZWxlY3RlZEluZGV4KV1gICovXG4gICAgICAgIF90aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gZm9jdXMgaGFzIGNoYW5nZWQgd2l0aGluIGEgdGFiIGdyb3VwLiAqL1xuICAgICAgICBfdGhpcy5mb2N1c0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYm9keSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZCAqL1xuICAgICAgICBfdGhpcy5hbmltYXRpb25Eb25lID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLiAqL1xuICAgICAgICBfdGhpcy5zZWxlY3RlZFRhYkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIF90aGlzLl9ncm91cElkID0gbmV4dElkKys7XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gZGVmYXVsdENvbmZpZyAmJiBkZWZhdWx0Q29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uID9cbiAgICAgICAgICAgIGRlZmF1bHRDb25maWcuYW5pbWF0aW9uRHVyYXRpb24gOiAnNTAwbXMnO1xuICAgICAgICBfdGhpcy5kaXNhYmxlUGFnaW5hdGlvbiA9IGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZy5kaXNhYmxlUGFnaW5hdGlvbiAhPSBudWxsID9cbiAgICAgICAgICAgIGRlZmF1bHRDb25maWcuZGlzYWJsZVBhZ2luYXRpb24gOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX01hdFRhYkdyb3VwQmFzZS5wcm90b3R5cGUsIFwiZHluYW1pY0hlaWdodFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgZ3JvdXAgc2hvdWxkIGdyb3cgdG8gdGhlIHNpemUgb2YgdGhlIGFjdGl2ZSB0YWIuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHluYW1pY0hlaWdodDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZHluYW1pY0hlaWdodCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIHtcbiAgICAgICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHRhYi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4OyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLCBcImFuaW1hdGlvbkR1cmF0aW9uXCIsIHtcbiAgICAgICAgLyoqIER1cmF0aW9uIGZvciB0aGUgdGFiIGFuaW1hdGlvbi4gV2lsbCBiZSBub3JtYWxpemVkIHRvIG1pbGxpc2Vjb25kcyBpZiBubyB1bml0cyBhcmUgc2V0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24gPSAvXlxcZCskLy50ZXN0KHZhbHVlKSA/IHZhbHVlICsgJ21zJyA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX01hdFRhYkdyb3VwQmFzZS5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHtcbiAgICAgICAgLyoqIEJhY2tncm91bmQgY29sb3Igb2YgdGhlIHRhYiBncm91cC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIG5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm1hdC1iYWNrZ3JvdW5kLVwiICsgdGhpcy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWF0LWJhY2tncm91bmQtXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGNvbnRlbnQgaXMgY2hlY2tlZCwgdGhpcyBjb21wb25lbnQga25vd3Mgd2hhdCB0YWJzIGhhdmUgYmVlbiBkZWZpbmVkXG4gICAgICogYW5kIHdoYXQgdGhlIHNlbGVjdGVkIGluZGV4IHNob3VsZCBiZS4gVGhpcyBpcyB3aGVyZSB3ZSBjYW4ga25vdyBleGFjdGx5IHdoYXQgcG9zaXRpb25cbiAgICAgKiBlYWNoIHRhYiBzaG91bGQgYmUgaW4gYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaW5kZXgsIGFuZCBhZGRpdGlvbmFsbHkgd2Uga25vdyBob3dcbiAgICAgKiBhIG5ldyBzZWxlY3RlZCB0YWIgc2hvdWxkIHRyYW5zaXRpb24gaW4gKGZyb20gdGhlIGxlZnQgb3IgcmlnaHQpLlxuICAgICAqL1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRG9uJ3QgY2xhbXAgdGhlIGBpbmRleFRvU2VsZWN0YCBpbW1lZGlhdGVseSBpbiB0aGUgc2V0dGVyIGJlY2F1c2UgaXQgY2FuIGhhcHBlbiB0aGF0XG4gICAgICAgIC8vIHRoZSBhbW91bnQgb2YgdGFicyBjaGFuZ2VzIGJlZm9yZSB0aGUgYWN0dWFsIGNoYW5nZSBkZXRlY3Rpb24gcnVucy5cbiAgICAgICAgdmFyIGluZGV4VG9TZWxlY3QgPSB0aGlzLl9pbmRleFRvU2VsZWN0ID0gdGhpcy5fY2xhbXBUYWJJbmRleCh0aGlzLl9pbmRleFRvU2VsZWN0KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBjaGFuZ2UgaW4gc2VsZWN0ZWQgaW5kZXgsIGVtaXQgYSBjaGFuZ2UgZXZlbnQuIFNob3VsZCBub3QgdHJpZ2dlciBpZlxuICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgaW5kZXggaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT0gaW5kZXhUb1NlbGVjdCkge1xuICAgICAgICAgICAgdmFyIGlzRmlyc3RSdW5fMSA9IHRoaXMuX3NlbGVjdGVkSW5kZXggPT0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaXNGaXJzdFJ1bl8xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRhYkNoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4VG9TZWxlY3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZXNlIHZhbHVlcyBhZnRlciBjaGFuZ2UgZGV0ZWN0aW9uIGhhcyBydW5cbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjaGVja2VkIGNvbnRlbnQgbWF5IGNvbnRhaW4gcmVmZXJlbmNlcyB0byB0aGVtLlxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhYnMuZm9yRWFjaChmdW5jdGlvbiAodGFiLCBpbmRleCkgeyByZXR1cm4gdGFiLmlzQWN0aXZlID0gaW5kZXggPT09IGluZGV4VG9TZWxlY3Q7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNGaXJzdFJ1bl8xKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UuZW1pdChpbmRleFRvU2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXR1cCB0aGUgcG9zaXRpb24gZm9yIGVhY2ggdGFiIGFuZCBvcHRpb25hbGx5IHNldHVwIGFuIG9yaWdpbiBvbiB0aGUgbmV4dCBzZWxlY3RlZCB0YWIuXG4gICAgICAgIHRoaXMuX3RhYnMuZm9yRWFjaChmdW5jdGlvbiAodGFiLCBpbmRleCkge1xuICAgICAgICAgICAgdGFiLnBvc2l0aW9uID0gaW5kZXggLSBpbmRleFRvU2VsZWN0O1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHNlbGVjdGVkIHRhYiwgdGhlbiBzZXQgdXAgYW4gb3JpZ2luIGZvciB0aGUgbmV4dCBzZWxlY3RlZCB0YWJcbiAgICAgICAgICAgIC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgYWxyZWFkeS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIHRhYi5wb3NpdGlvbiA9PSAwICYmICF0YWIub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdGFiLm9yaWdpbiA9IGluZGV4VG9TZWxlY3QgLSBfdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4ICE9PSBpbmRleFRvU2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gaW5kZXhUb1NlbGVjdDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQWxsVGFiQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1RhYkxhYmVscygpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyBpbiB0aGUgYW1vdW50IG9mIHRhYnMsIGluIG9yZGVyIHRvIGJlXG4gICAgICAgIC8vIGFibGUgdG8gcmUtcmVuZGVyIHRoZSBjb250ZW50IGFzIG5ldyB0YWJzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICB0aGlzLl90YWJzU3Vic2NyaXB0aW9uID0gdGhpcy5fdGFicy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhUb1NlbGVjdCA9IF90aGlzLl9jbGFtcFRhYkluZGV4KF90aGlzLl9pbmRleFRvU2VsZWN0KTtcbiAgICAgICAgICAgIC8vIE1haW50YWluIHRoZSBwcmV2aW91c2x5LXNlbGVjdGVkIHRhYiBpZiBhIG5ldyB0YWIgaXMgYWRkZWQgb3IgcmVtb3ZlZCBhbmQgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgIC8vIGV4cGxpY2l0IGNoYW5nZSB0aGF0IHNlbGVjdHMgYSBkaWZmZXJlbnQgdGFiLlxuICAgICAgICAgICAgaWYgKGluZGV4VG9TZWxlY3QgPT09IF90aGlzLl9zZWxlY3RlZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhYnMgPSBfdGhpcy5fdGFicy50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJzW2ldLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gYm90aCB0byB0aGUgYF9pbmRleFRvU2VsZWN0YCBhbmQgYF9zZWxlY3RlZEluZGV4YCBzbyB3ZSBkb24ndCBmaXJlIGEgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQsIG90aGVyd2lzZSB0aGUgY29uc3VtZXIgbWF5IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGluIHNvbWUgZWRnZSBjYXNlcyBsaWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgYSB0YWIgd2l0aGluIHRoZSBgc2VsZWN0ZWRJbmRleENoYW5nZWAgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5kZXhUb1NlbGVjdCA9IF90aGlzLl9zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBMaXN0ZW5zIHRvIGNoYW5nZXMgaW4gYWxsIG9mIHRoZSB0YWJzLiAqL1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLl9zdWJzY3JpYmVUb0FsbFRhYkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFNpbmNlIHdlIHVzZSBhIHF1ZXJ5IHdpdGggYGRlc2NlbmRhbnRzOiB0cnVlYCB0byBwaWNrIHVwIHRoZSB0YWJzLCB3ZSBtYXkgZW5kIHVwIGNhdGNoaW5nXG4gICAgICAgIC8vIHNvbWUgdGhhdCBhcmUgaW5zaWRlIG9mIG5lc3RlZCB0YWIgZ3JvdXBzLiBXZSBmaWx0ZXIgdGhlbSBvdXQgbWFudWFsbHkgYnkgY2hlY2tpbmcgdGhhdFxuICAgICAgICAvLyB0aGUgY2xvc2VzdCBncm91cCB0byB0aGUgdGFiIGlzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgdGhpcy5fYWxsVGFicy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodGhpcy5fYWxsVGFicykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICh0YWJzKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGFicy5yZXNldCh0YWJzLmZpbHRlcihmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgICAgICAgICAgLy8gQGJyZWFraW5nLWNoYW5nZSAxMC4wLjAgUmVtb3ZlIG51bGwgY2hlY2sgZm9yIGBfY2xvc2VzdFRhYkdyb3VwYFxuICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgYmVjb21lcyBhIHJlcXVpcmVkIHBhcmFtZXRlciBpbiBNYXRUYWIuXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0YWIuX2Nsb3Nlc3RUYWJHcm91cCB8fCB0YWIuX2Nsb3Nlc3RUYWJHcm91cCA9PT0gX3RoaXM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpcy5fdGFicy5ub3RpZnlPbkNoYW5nZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFicy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3RhYnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIC8qKiBSZS1hbGlnbnMgdGhlIGluayBiYXIgdG8gdGhlIHNlbGVjdGVkIHRhYiBlbGVtZW50LiAqL1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLnJlYWxpZ25JbmtCYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWJIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYkhlYWRlci5fYWxpZ25JbmtCYXJUb1NlbGVjdGVkVGFiKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLl9mb2N1c0NoYW5nZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5mb2N1c0NoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4KSk7XG4gICAgfTtcbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1hdFRhYkNoYW5nZUV2ZW50O1xuICAgICAgICBldmVudC5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAodGhpcy5fdGFicyAmJiB0aGlzLl90YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgZXZlbnQudGFiID0gdGhpcy5fdGFicy50b0FycmF5KClbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gY2hhbmdlcyBpbiB0aGUgdGFiIGxhYmVscy4gVGhpcyBpcyBuZWVkZWQsIGJlY2F1c2UgdGhlIEBJbnB1dCBmb3IgdGhlIGxhYmVsIGlzXG4gICAgICogb24gdGhlIE1hdFRhYiBjb21wb25lbnQsIHdoZXJlYXMgdGhlIGRhdGEgYmluZGluZyBpcyBpbnNpZGUgdGhlIE1hdFRhYkdyb3VwLiBJbiBvcmRlciBmb3IgdGhlXG4gICAgICogYmluZGluZyB0byBiZSB1cGRhdGVkLCB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIGl0IGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKiBtYW51YWxseS5cbiAgICAgKi9cbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9UYWJMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdGFiTGFiZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWJMYWJlbFN1YnNjcmlwdGlvbiA9IG1lcmdlLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQodGhpcy5fdGFicy5tYXAoZnVuY3Rpb24gKHRhYikgeyByZXR1cm4gdGFiLl9zdGF0ZUNoYW5nZXM7IH0pKSkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTsgfSk7XG4gICAgfTtcbiAgICAvKiogQ2xhbXBzIHRoZSBnaXZlbiBpbmRleCB0byB0aGUgYm91bmRzIG9mIDAgYW5kIHRoZSB0YWJzIGxlbmd0aC4gKi9cbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5fY2xhbXBUYWJJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBOb3RlIHRoZSBgfHwgMGAsIHdoaWNoIGVuc3VyZXMgdGhhdCB2YWx1ZXMgbGlrZSBOYU4gY2FuJ3QgZ2V0IHRocm91Z2hcbiAgICAgICAgLy8gYW5kIHdoaWNoIHdvdWxkIG90aGVyd2lzZSB0aHJvdyB0aGUgY29tcG9uZW50IGludG8gYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAvLyAoc2luY2UgTWF0aC5tYXgoTmFOLCAwKSA9PT0gTmFOKS5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX3RhYnMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoaW5kZXggfHwgMCwgMCkpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnQgKi9cbiAgICBfTWF0VGFiR3JvdXBCYXNlLnByb3RvdHlwZS5fZ2V0VGFiTGFiZWxJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1hdC10YWItbGFiZWwtXCIgKyB0aGlzLl9ncm91cElkICsgXCItXCIgKyBpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGNvbnRlbnQgZWxlbWVudCAqL1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLl9nZXRUYWJDb250ZW50SWQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gXCJtYXQtdGFiLWNvbnRlbnQtXCIgKyB0aGlzLl9ncm91cElkICsgXCItXCIgKyBpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBib2R5IHdyYXBwZXIgdG8gdGhlIGhlaWdodCBvZiB0aGUgYWN0aXZhdGluZyB0YWIgaWYgZHluYW1pY1xuICAgICAqIGhlaWdodCBwcm9wZXJ0eSBpcyB0cnVlLlxuICAgICAqL1xuICAgIF9NYXRUYWJHcm91cEJhc2UucHJvdG90eXBlLl9zZXRUYWJCb2R5V3JhcHBlckhlaWdodCA9IGZ1bmN0aW9uICh0YWJIZWlnaHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9keW5hbWljSGVpZ2h0IHx8ICF0aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwcGVyID0gdGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgd3JhcHBlci5zdHlsZS5oZWlnaHQgPSB0aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCArICdweCc7XG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZm9yY2VzIHRoZSBicm93c2VyIHRvIHBhaW50IHRoZSBoZWlnaHQgc28gdGhhdFxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHRoZSBuZXcgaGVpZ2h0IGNhbiBoYXZlIGFuIG9yaWdpbi5cbiAgICAgICAgaWYgKHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IHRhYkhlaWdodCArICdweCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZW1vdmVzIHRoZSBoZWlnaHQgb2YgdGhlIHRhYiBib2R5IHdyYXBwZXIuICovXG4gICAgX01hdFRhYkdyb3VwQmFzZS5wcm90b3R5cGUuX3JlbW92ZVRhYkJvZHlXcmFwcGVySGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ID0gd3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRG9uZS5lbWl0KCk7XG4gICAgfTtcbiAgICAvKiogSGFuZGxlIGNsaWNrIGV2ZW50cywgc2V0dGluZyBuZXcgc2VsZWN0ZWQgaW5kZXggaWYgYXBwcm9wcmlhdGUuICovXG4gICAgX01hdFRhYkdyb3VwQmFzZS5wcm90b3R5cGUuX2hhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHRhYiwgdGFiSGVhZGVyLCBpbmRleCkge1xuICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGFiSGVhZGVyLmZvY3VzSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFJldHJpZXZlcyB0aGUgdGFiaW5kZXggZm9yIHRoZSB0YWIuICovXG4gICAgX01hdFRhYkdyb3VwQmFzZS5wcm90b3R5cGUuX2dldFRhYkluZGV4ID0gZnVuY3Rpb24gKHRhYiwgaWR4KSB7XG4gICAgICAgIGlmICh0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXggPT09IGlkeCA/IDAgOiAtMTtcbiAgICB9O1xuICAgIF9NYXRUYWJHcm91cEJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUgfVxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgX01hdFRhYkdyb3VwQmFzZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW01BVF9UQUJTX0NPTkZJRyxdIH0sIHsgdHlwZTogT3B0aW9uYWwgfV0gfSxcbiAgICAgICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFLF0gfV0gfVxuICAgIF07IH07XG4gICAgX01hdFRhYkdyb3VwQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgZHluYW1pY0hlaWdodDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBoZWFkZXJQb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgZGlzYWJsZVBhZ2luYXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBzZWxlY3RlZEluZGV4Q2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIGZvY3VzQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgICAgIGFuaW1hdGlvbkRvbmU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICAgICAgc2VsZWN0ZWRUYWJDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxuICAgIH07XG4gICAgcmV0dXJuIF9NYXRUYWJHcm91cEJhc2U7XG59KF9NYXRUYWJHcm91cE1peGluQmFzZSkpO1xuZXhwb3J0IHsgX01hdFRhYkdyb3VwQmFzZSB9O1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gdGFiLWdyb3VwIGNvbXBvbmVudC4gU3VwcG9ydHMgYmFzaWMgdGFiIHBhaXJzIChsYWJlbCArIGNvbnRlbnQpIGFuZCBpbmNsdWRlc1xuICogYW5pbWF0ZWQgaW5rLWJhciwga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYW5kIHNjcmVlbiByZWFkZXIuXG4gKiBTZWU6IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2NvbXBvbmVudHMvdGFicy5odG1sXG4gKi9cbnZhciBNYXRUYWJHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0VGFiR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0VGFiR3JvdXAoZWxlbWVudFJlZiwgY2hhbmdlRGV0ZWN0b3JSZWYsIGRlZmF1bHRDb25maWcsIGFuaW1hdGlvbk1vZGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnRSZWYsIGNoYW5nZURldGVjdG9yUmVmLCBkZWZhdWx0Q29uZmlnLCBhbmltYXRpb25Nb2RlKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYXRUYWJHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtdGFiLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtYXRUYWJHcm91cCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxtYXQtdGFiLWhlYWRlciAjdGFiSGVhZGVyXFxuICAgICAgICAgICAgICAgW3NlbGVjdGVkSW5kZXhdPVxcXCJzZWxlY3RlZEluZGV4IHx8IDBcXFwiXFxuICAgICAgICAgICAgICAgW2Rpc2FibGVSaXBwbGVdPVxcXCJkaXNhYmxlUmlwcGxlXFxcIlxcbiAgICAgICAgICAgICAgIFtkaXNhYmxlUGFnaW5hdGlvbl09XFxcImRpc2FibGVQYWdpbmF0aW9uXFxcIlxcbiAgICAgICAgICAgICAgIChpbmRleEZvY3VzZWQpPVxcXCJfZm9jdXNDaGFuZ2VkKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgKHNlbGVjdEZvY3VzZWRJbmRleCk9XFxcInNlbGVjdGVkSW5kZXggPSAkZXZlbnRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbFxcXCIgcm9sZT1cXFwidGFiXFxcIiBtYXRUYWJMYWJlbFdyYXBwZXIgbWF0LXJpcHBsZSBjZGtNb25pdG9yRWxlbWVudEZvY3VzXFxuICAgICAgICpuZ0Zvcj1cXFwibGV0IHRhYiBvZiBfdGFiczsgbGV0IGkgPSBpbmRleFxcXCJcXG4gICAgICAgW2lkXT1cXFwiX2dldFRhYkxhYmVsSWQoaSlcXFwiXFxuICAgICAgIFthdHRyLnRhYkluZGV4XT1cXFwiX2dldFRhYkluZGV4KHRhYiwgaSlcXFwiXFxuICAgICAgIFthdHRyLmFyaWEtcG9zaW5zZXRdPVxcXCJpICsgMVxcXCJcXG4gICAgICAgW2F0dHIuYXJpYS1zZXRzaXplXT1cXFwiX3RhYnMubGVuZ3RoXFxcIlxcbiAgICAgICBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCJcXG4gICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCJcXG4gICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XFxcInRhYi5hcmlhTGFiZWwgfHwgbnVsbFxcXCJcXG4gICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiKCF0YWIuYXJpYUxhYmVsICYmIHRhYi5hcmlhTGFiZWxsZWRieSkgPyB0YWIuYXJpYUxhYmVsbGVkYnkgOiBudWxsXFxcIlxcbiAgICAgICBbY2xhc3MubWF0LXRhYi1sYWJlbC1hY3RpdmVdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiXFxuICAgICAgIFtkaXNhYmxlZF09XFxcInRhYi5kaXNhYmxlZFxcXCJcXG4gICAgICAgW21hdFJpcHBsZURpc2FibGVkXT1cXFwidGFiLmRpc2FibGVkIHx8IGRpc2FibGVSaXBwbGVcXFwiXFxuICAgICAgIChjbGljayk9XFxcIl9oYW5kbGVDbGljayh0YWIsIHRhYkhlYWRlciwgaSlcXFwiPlxcblxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxhYmVsLWNvbnRlbnRcXFwiPlxcbiAgICAgIDwhLS0gSWYgdGhlcmUgaXMgYSBsYWJlbCB0ZW1wbGF0ZSwgdXNlIGl0LiAtLT5cXG4gICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVxcXCJ0YWIudGVtcGxhdGVMYWJlbFxcXCI+XFxuICAgICAgICA8bmctdGVtcGxhdGUgW2Nka1BvcnRhbE91dGxldF09XFxcInRhYi50ZW1wbGF0ZUxhYmVsXFxcIj48L25nLXRlbXBsYXRlPlxcbiAgICAgIDwvbmctdGVtcGxhdGU+XFxuXFxuICAgICAgPCEtLSBJZiB0aGVyZSBpcyBub3QgYSBsYWJlbCB0ZW1wbGF0ZSwgZmFsbCBiYWNrIHRvIHRoZSB0ZXh0IGxhYmVsLiAtLT5cXG4gICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVxcXCIhdGFiLnRlbXBsYXRlTGFiZWxcXFwiPnt7dGFiLnRleHRMYWJlbH19PC9uZy10ZW1wbGF0ZT5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L21hdC10YWItaGVhZGVyPlxcblxcbjxkaXZcXG4gIGNsYXNzPVxcXCJtYXQtdGFiLWJvZHktd3JhcHBlclxcXCJcXG4gIFtjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZV09XFxcIl9hbmltYXRpb25Nb2RlID09PSAnTm9vcEFuaW1hdGlvbnMnXFxcIlxcbiAgI3RhYkJvZHlXcmFwcGVyPlxcbiAgPG1hdC10YWItYm9keSByb2xlPVxcXCJ0YWJwYW5lbFxcXCJcXG4gICAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCB0YWIgb2YgX3RhYnM7IGxldCBpID0gaW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgW2lkXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCJcXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCJcXG4gICAgICAgICAgICAgICBbY2xhc3MubWF0LXRhYi1ib2R5LWFjdGl2ZV09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCJcXG4gICAgICAgICAgICAgICBbY29udGVudF09XFxcInRhYi5jb250ZW50IVxcXCJcXG4gICAgICAgICAgICAgICBbcG9zaXRpb25dPVxcXCJ0YWIucG9zaXRpb24hXFxcIlxcbiAgICAgICAgICAgICAgIFtvcmlnaW5dPVxcXCJ0YWIub3JpZ2luXFxcIlxcbiAgICAgICAgICAgICAgIFthbmltYXRpb25EdXJhdGlvbl09XFxcImFuaW1hdGlvbkR1cmF0aW9uXFxcIlxcbiAgICAgICAgICAgICAgIChfb25DZW50ZXJlZCk9XFxcIl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCgpXFxcIlxcbiAgICAgICAgICAgICAgIChfb25DZW50ZXJpbmcpPVxcXCJfc2V0VGFiQm9keVdyYXBwZXJIZWlnaHQoJGV2ZW50KVxcXCI+XFxuICA8L21hdC10YWItYm9keT5cXG48L2Rpdj5cXG5cIixcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhbGlkYXRlLWRlY29yYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sb3InLCAnZGlzYWJsZVJpcHBsZSddLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTUFUX1RBQl9HUk9VUCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogTWF0VGFiR3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXRhYi1ncm91cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHRdJzogJ2R5bmFtaWNIZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlcl0nOiAnaGVhZGVyUG9zaXRpb24gPT09IFwiYmVsb3dcIicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC10YWItZ3JvdXB7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0ubWF0LXRhYi1ncm91cC5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlcntmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX0ubWF0LXRhYi1sYWJlbHtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMjRweDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTouNjttaW4td2lkdGg6MTYwcHg7dGV4dC1hbGlnbjpjZW50ZXI7ZGlzcGxheTppbmxpbmUtZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC10YWItbGFiZWw6Zm9jdXN7b3V0bGluZTpub25lfS5tYXQtdGFiLWxhYmVsOmZvY3VzOm5vdCgubWF0LXRhYi1kaXNhYmxlZCl7b3BhY2l0eToxfS5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC10YWItbGFiZWw6Zm9jdXN7b3V0bGluZTpkb3R0ZWQgMnB4O291dGxpbmUtb2Zmc2V0Oi0ycHh9Lm1hdC10YWItbGFiZWwubWF0LXRhYi1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0uY2RrLWhpZ2gtY29udHJhc3QtYWN0aXZlIC5tYXQtdGFiLWxhYmVsLm1hdC10YWItZGlzYWJsZWR7b3BhY2l0eTouNX0ubWF0LXRhYi1sYWJlbCAubWF0LXRhYi1sYWJlbC1jb250ZW50e2Rpc3BsYXk6aW5saW5lLWZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwfS5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC10YWItbGFiZWx7b3BhY2l0eToxfUBtZWRpYShtYXgtd2lkdGg6IDU5OXB4KXsubWF0LXRhYi1sYWJlbHtwYWRkaW5nOjAgMTJweH19QG1lZGlhKG1heC13aWR0aDogOTU5cHgpey5tYXQtdGFiLWxhYmVse3BhZGRpbmc6MCAxMnB4fX0ubWF0LXRhYi1ncm91cFttYXQtc3RyZXRjaC10YWJzXT4ubWF0LXRhYi1oZWFkZXIgLm1hdC10YWItbGFiZWx7ZmxleC1iYXNpczowO2ZsZXgtZ3JvdzoxfS5tYXQtdGFiLWJvZHktd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW47ZGlzcGxheTpmbGV4O3RyYW5zaXRpb246aGVpZ2h0IDUwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKX0uX21hdC1hbmltYXRpb24tbm9vcGFibGUubWF0LXRhYi1ib2R5LXdyYXBwZXJ7dHJhbnNpdGlvbjpub25lO2FuaW1hdGlvbjpub25lfS5tYXQtdGFiLWJvZHl7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW47ZmxleC1iYXNpczoxMDAlfS5tYXQtdGFiLWJvZHkubWF0LXRhYi1ib2R5LWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG87ei1pbmRleDoxO2ZsZXgtZ3JvdzoxfS5tYXQtdGFiLWdyb3VwLm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHQgLm1hdC10YWItYm9keS5tYXQtdGFiLWJvZHktYWN0aXZle292ZXJmbG93LXk6aGlkZGVufVxcblwiXVxuICAgICAgICAgICAgICAgIH1dIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hdFRhYkdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICAgICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTUFUX1RBQlNfQ09ORklHLF0gfSwgeyB0eXBlOiBPcHRpb25hbCB9XSB9LFxuICAgICAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBTklNQVRJT05fTU9EVUxFX1RZUEUsXSB9XSB9XG4gICAgXTsgfTtcbiAgICBNYXRUYWJHcm91cC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgX2FsbFRhYnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01hdFRhYiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgICAgIF90YWJCb2R5V3JhcHBlcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3RhYkJvZHlXcmFwcGVyJyxdIH1dLFxuICAgICAgICBfdGFiSGVhZGVyOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndGFiSGVhZGVyJyxdIH1dXG4gICAgfTtcbiAgICByZXR1cm4gTWF0VGFiR3JvdXA7XG59KF9NYXRUYWJHcm91cEJhc2UpKTtcbmV4cG9ydCB7IE1hdFRhYkdyb3VwIH07XG4iXX0=