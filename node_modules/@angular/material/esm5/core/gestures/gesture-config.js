/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __extends } from "tslib";
import { Injectable, InjectionToken, Inject, Optional } from '@angular/core';
import { HammerGestureConfig } from '@angular/platform-browser';
import { MatCommonModule } from '../common-behaviors/common-module';
/**
 * Injection token that can be used to provide options to the Hammerjs instance.
 * More info at http://hammerjs.github.io/api/.
 * @deprecated No longer being used. To be removed.
 * @breaking-change 10.0.0
 */
import * as ɵngcc0 from '@angular/core';
export var MAT_HAMMER_OPTIONS = new InjectionToken('MAT_HAMMER_OPTIONS');
var ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES = [
    'longpress',
    'slide',
    'slidestart',
    'slideend',
    'slideright',
    'slideleft'
];
var ɵ0 = function () { }, ɵ1 = function () { };
/**
 * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not
 * been loaded on the page.
 */
var noopHammerInstance = {
    on: ɵ0,
    off: ɵ1,
};
/**
 * Adjusts configuration of our gesture library, Hammer.
 * @deprecated No longer being used. To be removed.
 * @breaking-change 10.0.0
 */
var GestureConfig = /** @class */ (function (_super) {
    __extends(GestureConfig, _super);
    function GestureConfig(_hammerOptions, _commonModule) {
        var _this = _super.call(this) || this;
        _this._hammerOptions = _hammerOptions;
        /** List of new event names to add to the gesture support list */
        _this.events = ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES;
        return _this;
    }
    /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param element Element to which to assign the new HammerJS gestures.
     * @returns Newly-created HammerJS instance.
     */
    GestureConfig.prototype.buildHammer = function (element) {
        var hammer = typeof window !== 'undefined' ? window.Hammer : null;
        if (!hammer) {
            // If HammerJS is not loaded here, return the noop HammerInstance. This is necessary to
            // ensure that omitting HammerJS completely will not cause any errors while *also* supporting
            // the lazy-loading of HammerJS via the HAMMER_LOADER token introduced in Angular 6.1.
            // Because we can't depend on HAMMER_LOADER's existance until 7.0, we have to always set
            // `this.events` to the set we support, instead of conditionally setting it to `[]` if
            // `HAMMER_LOADER` is present (and then throwing an Error here if `window.Hammer` is
            // undefined).
            // @breaking-change 8.0.0
            return noopHammerInstance;
        }
        var mc = new hammer(element, this._hammerOptions || undefined);
        // Default Hammer Recognizers.
        var pan = new hammer.Pan();
        var swipe = new hammer.Swipe();
        var press = new hammer.Press();
        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
        // Otherwise the previous `recognizeWith` will be dropped.
        // TODO: Confirm threshold numbers with Material Design UX Team
        var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
        var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
        // Overwrite the default `pan` event to use the swipe event.
        pan.recognizeWith(swipe);
        // Since the slide event threshold is set to zero, the slide recognizer can fire and
        // accidentally reset the longpress recognizer. In order to make sure that the two
        // recognizers can run simultaneously but don't affect each other, we allow the slide
        // recognizer to recognize while a longpress is being processed.
        // See: https://github.com/hammerjs/hammer.js/blob/master/src/manager.js#L123-L124
        longpress.recognizeWith(slide);
        // Add customized gestures to Hammer manager
        mc.add([swipe, press, pan, slide, longpress]);
        return mc;
    };
    /** Creates a new recognizer, without affecting the default recognizers of HammerJS */
    GestureConfig.prototype._createRecognizer = function (base, options) {
        var inheritances = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            inheritances[_i - 2] = arguments[_i];
        }
        var recognizer = new base.constructor(options);
        inheritances.push(base);
        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
        return recognizer;
    };
    /** @nocollapse */
    GestureConfig.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_HAMMER_OPTIONS,] }] },
        { type: MatCommonModule, decorators: [{ type: Optional }] }
    ]; };
GestureConfig.ɵfac = function GestureConfig_Factory(t) { return new (t || GestureConfig)(ɵngcc0.ɵɵinject(MAT_HAMMER_OPTIONS, 8), ɵngcc0.ɵɵinject(MatCommonModule, 8)); };
GestureConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GestureConfig, factory: function (t) { return GestureConfig.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GestureConfig, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MAT_HAMMER_OPTIONS]
            }] }, { type: MatCommonModule, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return GestureConfig;
}(HammerGestureConfig));
export { GestureConfig };
export { ɵ0, ɵ1 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZXNtNS9jb3JlL2dlc3R1cmVzL2dlc3R1cmUtY29uZmlnLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTBGTSxBQUdBOzs7Ozs7Ozs7Ozs7Ozs7OztrQ0FLRyIsImZpbGUiOiJnZXN0dXJlLWNvbmZpZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGFtbWVyR2VzdHVyZUNvbmZpZyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgTWF0Q29tbW9uTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uLWJlaGF2aW9ycy9jb21tb24tbW9kdWxlJztcbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBvcHRpb25zIHRvIHRoZSBIYW1tZXJqcyBpbnN0YW5jZS5cbiAqIE1vcmUgaW5mbyBhdCBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8uXG4gKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgYmVpbmcgdXNlZC4gVG8gYmUgcmVtb3ZlZC5cbiAqIEBicmVha2luZy1jaGFuZ2UgMTAuMC4wXG4gKi9cbmV4cG9ydCB2YXIgTUFUX0hBTU1FUl9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdNQVRfSEFNTUVSX09QVElPTlMnKTtcbnZhciBBTkdVTEFSX01BVEVSSUFMX1NVUFBPUlRFRF9IQU1NRVJfR0VTVFVSRVMgPSBbXG4gICAgJ2xvbmdwcmVzcycsXG4gICAgJ3NsaWRlJyxcbiAgICAnc2xpZGVzdGFydCcsXG4gICAgJ3NsaWRlZW5kJyxcbiAgICAnc2xpZGVyaWdodCcsXG4gICAgJ3NsaWRlbGVmdCdcbl07XG52YXIgybUwID0gZnVuY3Rpb24gKCkgeyB9LCDJtTEgPSBmdW5jdGlvbiAoKSB7IH07XG4vKipcbiAqIEZha2UgSGFtbWVySW5zdGFuY2UgdGhhdCBpcyB1c2VkIHdoZW4gYSBIYW1tZXIgaW5zdGFuY2UgaXMgcmVxdWVzdGVkIHdoZW4gSGFtbWVySlMgaGFzIG5vdFxuICogYmVlbiBsb2FkZWQgb24gdGhlIHBhZ2UuXG4gKi9cbnZhciBub29wSGFtbWVySW5zdGFuY2UgPSB7XG4gICAgb246IMm1MCxcbiAgICBvZmY6IMm1MSxcbn07XG4vKipcbiAqIEFkanVzdHMgY29uZmlndXJhdGlvbiBvZiBvdXIgZ2VzdHVyZSBsaWJyYXJ5LCBIYW1tZXIuXG4gKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgYmVpbmcgdXNlZC4gVG8gYmUgcmVtb3ZlZC5cbiAqIEBicmVha2luZy1jaGFuZ2UgMTAuMC4wXG4gKi9cbnZhciBHZXN0dXJlQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHZXN0dXJlQ29uZmlnLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlc3R1cmVDb25maWcoX2hhbW1lck9wdGlvbnMsIF9jb21tb25Nb2R1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2hhbW1lck9wdGlvbnMgPSBfaGFtbWVyT3B0aW9ucztcbiAgICAgICAgLyoqIExpc3Qgb2YgbmV3IGV2ZW50IG5hbWVzIHRvIGFkZCB0byB0aGUgZ2VzdHVyZSBzdXBwb3J0IGxpc3QgKi9cbiAgICAgICAgX3RoaXMuZXZlbnRzID0gQU5HVUxBUl9NQVRFUklBTF9TVVBQT1JURURfSEFNTUVSX0dFU1RVUkVTO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBIYW1tZXIgaW5zdGFuY2UgbWFudWFsbHkgdG8gYWRkIGN1c3RvbSByZWNvZ25pemVycyB0aGF0IG1hdGNoIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgKlxuICAgICAqIE91ciBnZXN0dXJlIG5hbWVzIGNvbWUgZnJvbSB0aGUgTWF0ZXJpYWwgRGVzaWduIGdlc3R1cmVzIHNwZWM6XG4gICAgICogaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vI2dlc3R1cmVzLXRvdWNoLW1lY2hhbmljc1xuICAgICAqXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZhdWx0IHJlY29nbml6ZXJzIGNhbiBiZSBmb3VuZCBpbiBIYW1tZXIgZG9jczpcbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcGFuL1xuICAgICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVjb2duaXplci1wcmVzcy9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gd2hpY2ggdG8gYXNzaWduIHRoZSBuZXcgSGFtbWVySlMgZ2VzdHVyZXMuXG4gICAgICogQHJldHVybnMgTmV3bHktY3JlYXRlZCBIYW1tZXJKUyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5idWlsZEhhbW1lciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBoYW1tZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5IYW1tZXIgOiBudWxsO1xuICAgICAgICBpZiAoIWhhbW1lcikge1xuICAgICAgICAgICAgLy8gSWYgSGFtbWVySlMgaXMgbm90IGxvYWRlZCBoZXJlLCByZXR1cm4gdGhlIG5vb3AgSGFtbWVySW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBvbWl0dGluZyBIYW1tZXJKUyBjb21wbGV0ZWx5IHdpbGwgbm90IGNhdXNlIGFueSBlcnJvcnMgd2hpbGUgKmFsc28qIHN1cHBvcnRpbmdcbiAgICAgICAgICAgIC8vIHRoZSBsYXp5LWxvYWRpbmcgb2YgSGFtbWVySlMgdmlhIHRoZSBIQU1NRVJfTE9BREVSIHRva2VuIGludHJvZHVjZWQgaW4gQW5ndWxhciA2LjEuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbid0IGRlcGVuZCBvbiBIQU1NRVJfTE9BREVSJ3MgZXhpc3RhbmNlIHVudGlsIDcuMCwgd2UgaGF2ZSB0byBhbHdheXMgc2V0XG4gICAgICAgICAgICAvLyBgdGhpcy5ldmVudHNgIHRvIHRoZSBzZXQgd2Ugc3VwcG9ydCwgaW5zdGVhZCBvZiBjb25kaXRpb25hbGx5IHNldHRpbmcgaXQgdG8gYFtdYCBpZlxuICAgICAgICAgICAgLy8gYEhBTU1FUl9MT0FERVJgIGlzIHByZXNlbnQgKGFuZCB0aGVuIHRocm93aW5nIGFuIEVycm9yIGhlcmUgaWYgYHdpbmRvdy5IYW1tZXJgIGlzXG4gICAgICAgICAgICAvLyB1bmRlZmluZWQpLlxuICAgICAgICAgICAgLy8gQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICAgICAgICAgICAgcmV0dXJuIG5vb3BIYW1tZXJJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWMgPSBuZXcgaGFtbWVyKGVsZW1lbnQsIHRoaXMuX2hhbW1lck9wdGlvbnMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gRGVmYXVsdCBIYW1tZXIgUmVjb2duaXplcnMuXG4gICAgICAgIHZhciBwYW4gPSBuZXcgaGFtbWVyLlBhbigpO1xuICAgICAgICB2YXIgc3dpcGUgPSBuZXcgaGFtbWVyLlN3aXBlKCk7XG4gICAgICAgIHZhciBwcmVzcyA9IG5ldyBoYW1tZXIuUHJlc3MoKTtcbiAgICAgICAgLy8gTm90aWNlIHRoYXQgYSBIYW1tZXJKUyByZWNvZ25pemVyIGNhbiBvbmx5IGRlcGVuZCBvbiBvbmUgb3RoZXIgcmVjb2duaXplciBvbmNlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHByZXZpb3VzIGByZWNvZ25pemVXaXRoYCB3aWxsIGJlIGRyb3BwZWQuXG4gICAgICAgIC8vIFRPRE86IENvbmZpcm0gdGhyZXNob2xkIG51bWJlcnMgd2l0aCBNYXRlcmlhbCBEZXNpZ24gVVggVGVhbVxuICAgICAgICB2YXIgc2xpZGUgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHBhbiwgeyBldmVudDogJ3NsaWRlJywgdGhyZXNob2xkOiAwIH0sIHN3aXBlKTtcbiAgICAgICAgdmFyIGxvbmdwcmVzcyA9IHRoaXMuX2NyZWF0ZVJlY29nbml6ZXIocHJlc3MsIHsgZXZlbnQ6ICdsb25ncHJlc3MnLCB0aW1lOiA1MDAgfSk7XG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBgcGFuYCBldmVudCB0byB1c2UgdGhlIHN3aXBlIGV2ZW50LlxuICAgICAgICBwYW4ucmVjb2duaXplV2l0aChzd2lwZSk7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBzbGlkZSBldmVudCB0aHJlc2hvbGQgaXMgc2V0IHRvIHplcm8sIHRoZSBzbGlkZSByZWNvZ25pemVyIGNhbiBmaXJlIGFuZFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcmVzZXQgdGhlIGxvbmdwcmVzcyByZWNvZ25pemVyLiBJbiBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdHdvXG4gICAgICAgIC8vIHJlY29nbml6ZXJzIGNhbiBydW4gc2ltdWx0YW5lb3VzbHkgYnV0IGRvbid0IGFmZmVjdCBlYWNoIG90aGVyLCB3ZSBhbGxvdyB0aGUgc2xpZGVcbiAgICAgICAgLy8gcmVjb2duaXplciB0byByZWNvZ25pemUgd2hpbGUgYSBsb25ncHJlc3MgaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9oYW1tZXJqcy9oYW1tZXIuanMvYmxvYi9tYXN0ZXIvc3JjL21hbmFnZXIuanMjTDEyMy1MMTI0XG4gICAgICAgIGxvbmdwcmVzcy5yZWNvZ25pemVXaXRoKHNsaWRlKTtcbiAgICAgICAgLy8gQWRkIGN1c3RvbWl6ZWQgZ2VzdHVyZXMgdG8gSGFtbWVyIG1hbmFnZXJcbiAgICAgICAgbWMuYWRkKFtzd2lwZSwgcHJlc3MsIHBhbiwgc2xpZGUsIGxvbmdwcmVzc10pO1xuICAgICAgICByZXR1cm4gbWM7XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyByZWNvZ25pemVyLCB3aXRob3V0IGFmZmVjdGluZyB0aGUgZGVmYXVsdCByZWNvZ25pemVycyBvZiBIYW1tZXJKUyAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLl9jcmVhdGVSZWNvZ25pemVyID0gZnVuY3Rpb24gKGJhc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGluaGVyaXRhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaW5oZXJpdGFuY2VzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gbmV3IGJhc2UuY29uc3RydWN0b3Iob3B0aW9ucyk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5wdXNoKGJhc2UpO1xuICAgICAgICBpbmhlcml0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW0pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfTtcbiAgICBHZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBHZXN0dXJlQ29uZmlnLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtNQVRfSEFNTUVSX09QVElPTlMsXSB9XSB9LFxuICAgICAgICB7IHR5cGU6IE1hdENvbW1vbk1vZHVsZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfV0gfVxuICAgIF07IH07XG4gICAgcmV0dXJuIEdlc3R1cmVDb25maWc7XG59KEhhbW1lckdlc3R1cmVDb25maWcpKTtcbmV4cG9ydCB7IEdlc3R1cmVDb25maWcgfTtcbmV4cG9ydCB7IMm1MCwgybUxIH07XG4iXX0=