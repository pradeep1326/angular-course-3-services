{"version":3,"sources":["c:/Users/puttp/Desktop/Angular/workspace/angular-course-3-services/node_modules/@angular/material/bundles/material-slide-toggle.umd.js"],"names":[],"mappings":"AAAA;kOAC2E;qMACgB;2IACrD;sDACnB;;;;;;AAAoF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAqN7F,AAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA4BD;;;;;;;;;;0BAMC;;;;;;;;;;;;;;SAcD;;;;;;;;;;gDAMC;;;;;SAKD;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAgBC","file":"material-slide-toggle.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/observers'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/forms'), require('@angular/platform-browser/animations')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/slide-toggle', ['exports', '@angular/cdk/observers', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/forms', '@angular/platform-browser/animations'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.slideToggle = {}), global.ng.cdk.observers, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.forms, global.ng.platformBrowser.animations));\n}(this, (function (exports, observers, core, core$1, tslib, a11y, bidi, coercion, forms, animations) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token to be used to override the default options for `mat-slide-toggle`. */\n    var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new core.InjectionToken('mat-slide-toggle-default-options', {\n        providedIn: 'root',\n        factory: function () { return ({ disableToggleValue: false }); }\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Increasing integer for generating unique ids for slide-toggle components.\n    var nextUniqueId = 0;\n    /** @docs-private */\n    var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatSlideToggle; }),\n        multi: true\n    };\n    /** Change event object emitted by a MatSlideToggle. */\n    var MatSlideToggleChange = /** @class */ (function () {\n        function MatSlideToggleChange(\n        /** The source MatSlideToggle of the event. */\n        source, \n        /** The new `checked` value of the MatSlideToggle. */\n        checked) {\n            this.source = source;\n            this.checked = checked;\n        }\n        return MatSlideToggleChange;\n    }());\n    // Boilerplate for applying mixins to MatSlideToggle.\n    /** @docs-private */\n    var MatSlideToggleBase = /** @class */ (function () {\n        function MatSlideToggleBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatSlideToggleBase;\n    }());\n    var _MatSlideToggleMixinBase = core$1.mixinTabIndex(core$1.mixinColor(core$1.mixinDisableRipple(core$1.mixinDisabled(MatSlideToggleBase)), 'accent'));\n    /** Represents a slidable \"switch\" toggle that can be moved between on and off. */\n    var MatSlideToggle = /** @class */ (function (_super) {\n        tslib.__extends(MatSlideToggle, _super);\n        function MatSlideToggle(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, \n        /**\n         * @deprecated `_ngZone` and `_dir` parameters to be removed.\n         * @breaking-change 10.0.0\n         */\n        _ngZone, defaults, _animationMode, _dir) {\n            var _this = _super.call(this, elementRef) || this;\n            _this._focusMonitor = _focusMonitor;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this.defaults = defaults;\n            _this._animationMode = _animationMode;\n            _this._onChange = function (_) { };\n            _this._onTouched = function () { };\n            _this._uniqueId = \"mat-slide-toggle-\" + ++nextUniqueId;\n            _this._required = false;\n            _this._checked = false;\n            /** Name value will be applied to the input element if present. */\n            _this.name = null;\n            /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */\n            _this.id = _this._uniqueId;\n            /** Whether the label should appear after or before the slide-toggle. Defaults to 'after'. */\n            _this.labelPosition = 'after';\n            /** Used to set the aria-label attribute on the underlying input element. */\n            _this.ariaLabel = null;\n            /** Used to set the aria-labelledby attribute on the underlying input element. */\n            _this.ariaLabelledby = null;\n            /** An event will be dispatched each time the slide-toggle changes its value. */\n            _this.change = new core.EventEmitter();\n            /**\n             * An event will be dispatched each time the slide-toggle input is toggled.\n             * This event is always emitted when the user toggles the slide toggle, but this does not mean\n             * the slide toggle's value has changed.\n             */\n            _this.toggleChange = new core.EventEmitter();\n            /**\n             * An event will be dispatched each time the slide-toggle is dragged.\n             * This event is always emitted when the user drags the slide toggle to make a change greater\n             * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n             * the user toggles the slide toggle to change its value.\n             * @deprecated No longer being used. To be removed.\n             * @breaking-change 10.0.0\n             */\n            _this.dragChange = new core.EventEmitter();\n            _this.tabIndex = parseInt(tabIndex) || 0;\n            return _this;\n        }\n        Object.defineProperty(MatSlideToggle.prototype, \"required\", {\n            /** Whether the slide-toggle is required. */\n            get: function () { return this._required; },\n            set: function (value) { this._required = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatSlideToggle.prototype, \"checked\", {\n            /** Whether the slide-toggle element is checked or not. */\n            get: function () { return this._checked; },\n            set: function (value) {\n                this._checked = coercion.coerceBooleanProperty(value);\n                this._changeDetectorRef.markForCheck();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatSlideToggle.prototype, \"inputId\", {\n            /** Returns the unique id for the visual hidden input. */\n            get: function () { return (this.id || this._uniqueId) + \"-input\"; },\n            enumerable: true,\n            configurable: true\n        });\n        MatSlideToggle.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._elementRef, true)\n                .subscribe(function (focusOrigin) {\n                if (!focusOrigin) {\n                    // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n                    // Angular does not expect events to be raised during change detection, so any state\n                    // change (such as a form control's 'ng-touched') will cause a changed-after-checked\n                    // error. See https://github.com/angular/angular/issues/17793. To work around this,\n                    // we defer telling the form control it has been touched until the next tick.\n                    Promise.resolve().then(function () { return _this._onTouched(); });\n                }\n            });\n        };\n        MatSlideToggle.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        };\n        /** Method being called whenever the underlying input emits a change event. */\n        MatSlideToggle.prototype._onChangeEvent = function (event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the component's `change` output.\n            event.stopPropagation();\n            this.toggleChange.emit();\n            // When the slide toggle's config disables toggle change event by setting\n            // `disableToggleValue: true`, the slide toggle's value does not change, and the\n            // checked state of the underlying input needs to be changed back.\n            if (this.defaults.disableToggleValue) {\n                this._inputElement.nativeElement.checked = this.checked;\n                return;\n            }\n            // Sync the value from the underlying input element with the component instance.\n            this.checked = this._inputElement.nativeElement.checked;\n            // Emit our custom change event only if the underlying input emitted one. This ensures that\n            // there is no change event, when the checked state changes programmatically.\n            this._emitChangeEvent();\n        };\n        /** Method being called whenever the slide-toggle has been clicked. */\n        MatSlideToggle.prototype._onInputClick = function (event) {\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `slide-toggle` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.writeValue = function (value) {\n            this.checked = !!value;\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        /** Implemented as a part of ControlValueAccessor. */\n        MatSlideToggle.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Focuses the slide-toggle. */\n        MatSlideToggle.prototype.focus = function (options) {\n            this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);\n        };\n        /** Toggles the checked state of the slide-toggle. */\n        MatSlideToggle.prototype.toggle = function () {\n            this.checked = !this.checked;\n            this._onChange(this.checked);\n        };\n        /**\n         * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n         */\n        MatSlideToggle.prototype._emitChangeEvent = function () {\n            this._onChange(this.checked);\n            this.change.emit(new MatSlideToggleChange(this, this.checked));\n        };\n        /** Method being called whenever the label text changes. */\n        MatSlideToggle.prototype._onLabelTextChange = function () {\n            // Since the event of the `cdkObserveContent` directive runs outside of the zone, the\n            // slide-toggle component will be only marked for check, but no actual change detection runs\n            // automatically. Instead of going back into the zone in order to trigger a change detection\n            // which causes *all* components to be checked (if explicitly marked or not using OnPush),\n            // we only trigger an explicit change detection for the slide-toggle view and its children.\n            this._changeDetectorRef.detectChanges();\n        };\n        MatSlideToggle.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-slide-toggle',\n                        exportAs: 'matSlideToggle',\n                        host: {\n                            'class': 'mat-slide-toggle',\n                            '[id]': 'id',\n                            // Needs to be `-1` so it can still receive programmatic focus.\n                            '[attr.tabindex]': 'disabled ? null : -1',\n                            '[attr.aria-label]': 'null',\n                            '[attr.aria-labelledby]': 'null',\n                            '[class.mat-checked]': 'checked',\n                            '[class.mat-disabled]': 'disabled',\n                            '[class.mat-slide-toggle-label-before]': 'labelPosition == \"before\"',\n                            '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                            '(focus)': '_inputElement.nativeElement.focus()',\n                        },\n                        template: \"<label [attr.for]=\\\"inputId\\\" class=\\\"mat-slide-toggle-label\\\" #label>\\n  <div #toggleBar class=\\\"mat-slide-toggle-bar\\\"\\n       [class.mat-slide-toggle-bar-no-side-margin]=\\\"!labelContent.textContent || !labelContent.textContent.trim()\\\">\\n\\n    <input #input class=\\\"mat-slide-toggle-input cdk-visually-hidden\\\" type=\\\"checkbox\\\"\\n           role=\\\"switch\\\"\\n           [id]=\\\"inputId\\\"\\n           [required]=\\\"required\\\"\\n           [tabIndex]=\\\"tabIndex\\\"\\n           [checked]=\\\"checked\\\"\\n           [disabled]=\\\"disabled\\\"\\n           [attr.name]=\\\"name\\\"\\n           [attr.aria-checked]=\\\"checked.toString()\\\"\\n           [attr.aria-label]=\\\"ariaLabel\\\"\\n           [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n           (change)=\\\"_onChangeEvent($event)\\\"\\n           (click)=\\\"_onInputClick($event)\\\">\\n\\n    <div class=\\\"mat-slide-toggle-thumb-container\\\" #thumbContainer>\\n      <div class=\\\"mat-slide-toggle-thumb\\\"></div>\\n      <div class=\\\"mat-slide-toggle-ripple\\\" mat-ripple\\n           [matRippleTrigger]=\\\"label\\\"\\n           [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n           [matRippleCentered]=\\\"true\\\"\\n           [matRippleRadius]=\\\"20\\\"\\n           [matRippleAnimation]=\\\"{enterDuration: 150}\\\">\\n\\n        <div class=\\\"mat-ripple-element mat-slide-toggle-persistent-ripple\\\"></div>\\n      </div>\\n    </div>\\n\\n  </div>\\n\\n  <span class=\\\"mat-slide-toggle-content\\\" #labelContent (cdkObserveContent)=\\\"_onLabelTextChange()\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\",\n                        providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],\n                        inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatSlideToggle.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: a11y.FocusMonitor },\n            { type: core.ChangeDetectorRef },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n            { type: core.NgZone },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }\n        ]; };\n        MatSlideToggle.propDecorators = {\n            _thumbEl: [{ type: core.ViewChild, args: ['thumbContainer',] }],\n            _thumbBarEl: [{ type: core.ViewChild, args: ['toggleBar',] }],\n            name: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            labelPosition: [{ type: core.Input }],\n            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],\n            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],\n            required: [{ type: core.Input }],\n            checked: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            toggleChange: [{ type: core.Output }],\n            dragChange: [{ type: core.Output }],\n            _inputElement: [{ type: core.ViewChild, args: ['input',] }]\n        };\n        return MatSlideToggle;\n    }(_MatSlideToggleMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {\n        provide: forms.NG_VALIDATORS,\n        useExisting: core.forwardRef(function () { return MatSlideToggleRequiredValidator; }),\n        multi: true\n    };\n    /**\n     * Validator for Material slide-toggle components with the required attribute in a\n     * template-driven form. The default validator for required form controls asserts\n     * that the control value is not undefined but that is not appropriate for a slide-toggle\n     * where the value is always defined.\n     *\n     * Required slide-toggle form controls are valid when checked.\n     */\n    var MatSlideToggleRequiredValidator = /** @class */ (function (_super) {\n        tslib.__extends(MatSlideToggleRequiredValidator, _super);\n        function MatSlideToggleRequiredValidator() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MatSlideToggleRequiredValidator.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"mat-slide-toggle[required][formControlName],\\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]\",\n                        providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],\n                    },] }\n        ];\n        return MatSlideToggleRequiredValidator;\n    }(forms.CheckboxRequiredValidator));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** This module is used by both original and MDC-based slide-toggle implementations. */\n    var _MatSlideToggleRequiredValidatorModule = /** @class */ (function () {\n        function _MatSlideToggleRequiredValidatorModule() {\n        }\n        _MatSlideToggleRequiredValidatorModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: [MatSlideToggleRequiredValidator],\n                        declarations: [MatSlideToggleRequiredValidator],\n                    },] }\n        ];\n        return _MatSlideToggleRequiredValidatorModule;\n    }());\n    var MatSlideToggleModule = /** @class */ (function () {\n        function MatSlideToggleModule() {\n        }\n        MatSlideToggleModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [\n                            _MatSlideToggleRequiredValidatorModule,\n                            core$1.MatRippleModule,\n                            core$1.MatCommonModule,\n                            observers.ObserversModule,\n                        ],\n                        exports: [\n                            _MatSlideToggleRequiredValidatorModule,\n                            MatSlideToggle,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatSlideToggle],\n                    },] }\n        ];\n        return MatSlideToggleModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS;\n    exports.MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR;\n    exports.MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = MAT_SLIDE_TOGGLE_VALUE_ACCESSOR;\n    exports.MatSlideToggle = MatSlideToggle;\n    exports.MatSlideToggleChange = MatSlideToggleChange;\n    exports.MatSlideToggleModule = MatSlideToggleModule;\n    exports.MatSlideToggleRequiredValidator = MatSlideToggleRequiredValidator;\n    exports._MatSlideToggleRequiredValidatorModule = _MatSlideToggleRequiredValidatorModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}