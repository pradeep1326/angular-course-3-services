{"version":3,"sources":["c:/Users/puttp/Desktop/Angular/workspace/angular-course-3-services/node_modules/@angular/material/bundles/material-input.umd.js"],"names":[],"mappings":"AAAA;uSAC2E;iPACS;0LAC9C;oEACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA0CR,AAaD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAuWA,AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAsBA;;;;;;;;;;;;;SAaD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAmBC","file":"material-input.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/text-field'), require('@angular/core'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('@angular/forms'), require('@angular/material/core'), require('@angular/material/form-field'), require('rxjs'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/input', ['exports', 'tslib', '@angular/cdk/text-field', '@angular/core', '@angular/cdk/coercion', '@angular/cdk/platform', '@angular/forms', '@angular/material/core', '@angular/material/form-field', 'rxjs', '@angular/common'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.input = {}), global.tslib, global.ng.cdk.textField, global.ng.core, global.ng.cdk.coercion, global.ng.cdk.platform, global.ng.forms, global.ng.material.core, global.ng.material.formField, global.rxjs, global.ng.common));\n}(this, (function (exports, tslib, textField, core, coercion, platform, forms, core$1, formField, rxjs, common) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Directive to automatically resize a textarea to fit its content.\n     * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n     * @breaking-change 8.0.0\n     */\n    var MatTextareaAutosize = /** @class */ (function (_super) {\n        tslib.__extends(MatTextareaAutosize, _super);\n        function MatTextareaAutosize() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMinRows\", {\n            get: function () { return this.minRows; },\n            set: function (value) { this.minRows = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMaxRows\", {\n            get: function () { return this.maxRows; },\n            set: function (value) { this.maxRows = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosize\", {\n            get: function () { return this.enabled; },\n            set: function (value) { this.enabled = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTextareaAutosize.prototype, \"matTextareaAutosize\", {\n            get: function () { return this.enabled; },\n            set: function (value) { this.enabled = value; },\n            enumerable: true,\n            configurable: true\n        });\n        MatTextareaAutosize.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                        exportAs: 'matTextareaAutosize',\n                        inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                        host: {\n                            'class': 'cdk-textarea-autosize mat-autosize',\n                            // Textarea elements that have the directive applied should have a single row by default.\n                            // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                            'rows': '1',\n                        },\n                    },] }\n        ];\n        MatTextareaAutosize.propDecorators = {\n            matAutosizeMinRows: [{ type: core.Input }],\n            matAutosizeMaxRows: [{ type: core.Input }],\n            matAutosize: [{ type: core.Input, args: ['mat-autosize',] }],\n            matTextareaAutosize: [{ type: core.Input }]\n        };\n        return MatTextareaAutosize;\n    }(textField.CdkTextareaAutosize));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** @docs-private */\n    function getMatInputUnsupportedTypeError(type) {\n        return Error(\"Input type \\\"\" + type + \"\\\" isn't supported by matInput.\");\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * This token is used to inject the object whose value should be set into `MatInput`. If none is\n     * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n     * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n     * value to them.\n     */\n    var MAT_INPUT_VALUE_ACCESSOR = new core.InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n    var MAT_INPUT_INVALID_TYPES = [\n        'button',\n        'checkbox',\n        'file',\n        'hidden',\n        'image',\n        'radio',\n        'range',\n        'reset',\n        'submit'\n    ];\n    var nextUniqueId = 0;\n    // Boilerplate for applying mixins to MatInput.\n    /** @docs-private */\n    var MatInputBase = /** @class */ (function () {\n        function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n        /** @docs-private */\n        ngControl) {\n            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n            this._parentForm = _parentForm;\n            this._parentFormGroup = _parentFormGroup;\n            this.ngControl = ngControl;\n        }\n        return MatInputBase;\n    }());\n    var _MatInputMixinBase = core$1.mixinErrorState(MatInputBase);\n    /** Directive that allows a native input to work inside a `MatFormField`. */\n    var MatInput = /** @class */ (function (_super) {\n        tslib.__extends(MatInput, _super);\n        function MatInput(_elementRef, _platform, \n        /** @docs-private */\n        ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n            _this._elementRef = _elementRef;\n            _this._platform = _platform;\n            _this.ngControl = ngControl;\n            _this._autofillMonitor = _autofillMonitor;\n            _this._uid = \"mat-input-\" + nextUniqueId++;\n            /** Whether the component is being rendered on the server. */\n            _this._isServer = false;\n            /** Whether the component is a native html select. */\n            _this._isNativeSelect = false;\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.focused = false;\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.stateChanges = new rxjs.Subject();\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.controlType = 'mat-input';\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.autofilled = false;\n            _this._disabled = false;\n            _this._required = false;\n            _this._type = 'text';\n            _this._readonly = false;\n            _this._neverEmptyInputTypes = [\n                'date',\n                'datetime',\n                'datetime-local',\n                'month',\n                'time',\n                'week'\n            ].filter(function (t) { return platform.getSupportedInputTypes().has(t); });\n            var element = _this._elementRef.nativeElement;\n            // If no input value accessor was explicitly specified, use the element as the input value\n            // accessor.\n            _this._inputValueAccessor = inputValueAccessor || element;\n            _this._previousNativeValue = _this.value;\n            // Force setter to be called in case id was not specified.\n            _this.id = _this.id;\n            // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n            // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n            // exists on iOS, we only bother to install the listener on iOS.\n            if (_platform.IOS) {\n                ngZone.runOutsideAngular(function () {\n                    _elementRef.nativeElement.addEventListener('keyup', function (event) {\n                        var el = event.target;\n                        if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                            // `1, 1` fixes it for the first time that you type text and\n                            // then hold delete. Toggling to `1, 1` and then back to\n                            // `0, 0` seems to completely fix it.\n                            el.setSelectionRange(1, 1);\n                            el.setSelectionRange(0, 0);\n                        }\n                    });\n                });\n            }\n            _this._isServer = !_this._platform.isBrowser;\n            _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\n            if (_this._isNativeSelect) {\n                _this.controlType = element.multiple ? 'mat-native-select-multiple' :\n                    'mat-native-select';\n            }\n            return _this;\n        }\n        Object.defineProperty(MatInput.prototype, \"disabled\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                if (this.ngControl && this.ngControl.disabled !== null) {\n                    return this.ngControl.disabled;\n                }\n                return this._disabled;\n            },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                // Browsers may not fire the blur event if the input is disabled too quickly.\n                // Reset from here to ensure that the element doesn't become stuck.\n                if (this.focused) {\n                    this.focused = false;\n                    this.stateChanges.next();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"id\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._id; },\n            set: function (value) { this._id = value || this._uid; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"required\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._required; },\n            set: function (value) { this._required = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"type\", {\n            /** Input type of the element. */\n            get: function () { return this._type; },\n            set: function (value) {\n                this._type = value || 'text';\n                this._validateType();\n                // When using Angular inputs, developers are no longer able to set the properties on the native\n                // input element. To ensure that bindings for `type` work, we need to sync the setter\n                // with the native property. Textarea elements don't support the type property or attribute.\n                if (!this._isTextarea() && platform.getSupportedInputTypes().has(this._type)) {\n                    this._elementRef.nativeElement.type = this._type;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"value\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._inputValueAccessor.value; },\n            set: function (value) {\n                if (value !== this.value) {\n                    this._inputValueAccessor.value = value;\n                    this.stateChanges.next();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"readonly\", {\n            /** Whether the element is readonly. */\n            get: function () { return this._readonly; },\n            set: function (value) { this._readonly = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        MatInput.prototype.ngOnInit = function () {\n            var _this = this;\n            if (this._platform.isBrowser) {\n                this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n                    _this.autofilled = event.isAutofilled;\n                    _this.stateChanges.next();\n                });\n            }\n        };\n        MatInput.prototype.ngOnChanges = function () {\n            this.stateChanges.next();\n        };\n        MatInput.prototype.ngOnDestroy = function () {\n            this.stateChanges.complete();\n            if (this._platform.isBrowser) {\n                this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n            }\n        };\n        MatInput.prototype.ngDoCheck = function () {\n            if (this.ngControl) {\n                // We need to re-evaluate this on every change detection cycle, because there are some\n                // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n                // that whatever logic is in here has to be super lean or we risk destroying the performance.\n                this.updateErrorState();\n            }\n            // We need to dirty-check the native element's value, because there are some cases where\n            // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n            // updating the value using `emitEvent: false`).\n            this._dirtyCheckNativeValue();\n        };\n        /** Focuses the input. */\n        MatInput.prototype.focus = function (options) {\n            this._elementRef.nativeElement.focus(options);\n        };\n        /** Callback for the cases where the focused state of the input changes. */\n        MatInput.prototype._focusChanged = function (isFocused) {\n            if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n                this.focused = isFocused;\n                this.stateChanges.next();\n            }\n        };\n        MatInput.prototype._onInput = function () {\n            // This is a noop function and is used to let Angular know whenever the value changes.\n            // Angular will run a new change detection each time the `input` event has been dispatched.\n            // It's necessary that Angular recognizes the value change, because when floatingLabel\n            // is set to false and Angular forms aren't used, the placeholder won't recognize the\n            // value changes and will not disappear.\n            // Listening to the input event wouldn't be necessary when the input is using the\n            // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n        };\n        /** Determines if the component host is a textarea. */\n        MatInput.prototype._isTextarea = function () {\n            return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n        };\n        /** Does some manual dirty checking on the native input `value` property. */\n        MatInput.prototype._dirtyCheckNativeValue = function () {\n            var newValue = this._elementRef.nativeElement.value;\n            if (this._previousNativeValue !== newValue) {\n                this._previousNativeValue = newValue;\n                this.stateChanges.next();\n            }\n        };\n        /** Make sure the input is a supported type. */\n        MatInput.prototype._validateType = function () {\n            if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n                throw getMatInputUnsupportedTypeError(this._type);\n            }\n        };\n        /** Checks whether the input type is one of the types that are never empty. */\n        MatInput.prototype._isNeverEmpty = function () {\n            return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n        };\n        /** Checks whether the input is invalid based on the native validation. */\n        MatInput.prototype._isBadInput = function () {\n            // The `validity` property won't be present on platform-server.\n            var validity = this._elementRef.nativeElement.validity;\n            return validity && validity.badInput;\n        };\n        Object.defineProperty(MatInput.prototype, \"empty\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n                    !this.autofilled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatInput.prototype, \"shouldLabelFloat\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                if (this._isNativeSelect) {\n                    // For a single-selection `<select>`, the label should float when the selected option has\n                    // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n                    // overlapping the label with the options.\n                    var selectElement = this._elementRef.nativeElement;\n                    var firstOption = selectElement.options[0];\n                    // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n                    // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n                    return this.focused || selectElement.multiple || !this.empty ||\n                        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n                }\n                else {\n                    return this.focused || !this.empty;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatInput.prototype.setDescribedByIds = function (ids) {\n            this._ariaDescribedby = ids.join(' ');\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatInput.prototype.onContainerClick = function () {\n            // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n            // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n            // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n            if (!this.focused) {\n                this.focus();\n            }\n        };\n        MatInput.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\",\n                        exportAs: 'matInput',\n                        host: {\n                            /**\n                             * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                             */\n                            'class': 'mat-input-element mat-form-field-autofill-control',\n                            '[class.mat-input-server]': '_isServer',\n                            // Native input properties that are overwritten by Angular inputs need to be synced with\n                            // the native input element. Otherwise property bindings for those don't work.\n                            '[attr.id]': 'id',\n                            '[attr.placeholder]': 'placeholder',\n                            '[disabled]': 'disabled',\n                            '[required]': 'required',\n                            '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n                            '[attr.aria-describedby]': '_ariaDescribedby || null',\n                            '[attr.aria-invalid]': 'errorState',\n                            '[attr.aria-required]': 'required.toString()',\n                            '(blur)': '_focusChanged(false)',\n                            '(focus)': '_focusChanged(true)',\n                            '(input)': '_onInput()',\n                        },\n                        providers: [{ provide: formField.MatFormFieldControl, useExisting: MatInput }],\n                    },] }\n        ];\n        /** @nocollapse */\n        MatInput.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: platform.Platform },\n            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },\n            { type: forms.NgForm, decorators: [{ type: core.Optional }] },\n            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },\n            { type: core$1.ErrorStateMatcher },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\n            { type: textField.AutofillMonitor },\n            { type: core.NgZone }\n        ]; };\n        MatInput.propDecorators = {\n            disabled: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            placeholder: [{ type: core.Input }],\n            required: [{ type: core.Input }],\n            type: [{ type: core.Input }],\n            errorStateMatcher: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            readonly: [{ type: core.Input }]\n        };\n        return MatInput;\n    }(_MatInputMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatInputModule = /** @class */ (function () {\n        function MatInputModule() {\n        }\n        MatInputModule.decorators = [\n            { type: core.NgModule, args: [{\n                        declarations: [MatInput, MatTextareaAutosize],\n                        imports: [\n                            common.CommonModule,\n                            textField.TextFieldModule,\n                            formField.MatFormFieldModule,\n                        ],\n                        exports: [\n                            textField.TextFieldModule,\n                            // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n                            // be used together with `MatFormField`.\n                            formField.MatFormFieldModule,\n                            MatInput,\n                            MatTextareaAutosize,\n                        ],\n                        providers: [core$1.ErrorStateMatcher],\n                    },] }\n        ];\n        return MatInputModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_INPUT_VALUE_ACCESSOR = MAT_INPUT_VALUE_ACCESSOR;\n    exports.MatInput = MatInput;\n    exports.MatInputModule = MatInputModule;\n    exports.MatTextareaAutosize = MatTextareaAutosize;\n    exports.getMatInputUnsupportedTypeError = getMatInputUnsupportedTypeError;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}