/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, Component, Inject, InjectionToken, Input, Optional, ViewChild, ViewEncapsulation, isDevMode, } from '@angular/core';
import { CdkCellDef, CdkColumnDef, CdkHeaderCellDef } from './cell';
import { CdkTable } from './table';
import { getTableTextColumnMissingParentTableError, getTableTextColumnMissingNameError, } from './table-errors';
/** Injection token that can be used to specify the text column options. */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './cell';

function CdkTextColumn_th_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "th", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r224 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-align", ctx_r224.justify);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r224.headerText, " ");
} }
function CdkTextColumn_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var data_r226 = ctx.$implicit;
    var ctx_r225 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-align", ctx_r225.justify);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r225.dataAccessor(data_r226, ctx_r225.name), " ");
} }
export var TEXT_COLUMN_OPTIONS = new InjectionToken('text-column-options');
/**
 * Column that simply shows text content for the header and row cells. Assumes that the table
 * is using the native table implementation (`<table>`).
 *
 * By default, the name of this column will be the header text and data property accessor.
 * The header text can be overridden with the `headerText` input. Cell values can be overridden with
 * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
 * input.
 */
var CdkTextColumn = /** @class */ (function () {
    function CdkTextColumn(_table, _options) {
        this._table = _table;
        this._options = _options;
        /** Alignment of the cell values. */
        this.justify = 'start';
        this._options = _options || {};
    }
    Object.defineProperty(CdkTextColumn.prototype, "name", {
        /** Column name that should be used to reference this column. */
        get: function () {
            return this._name;
        },
        set: function (name) {
            this._name = name;
            // With Ivy, inputs can be initialized before static query results are
            // available. In that case, we defer the synchronization until "ngOnInit" fires.
            this._syncColumnDefName();
        },
        enumerable: true,
        configurable: true
    });
    CdkTextColumn.prototype.ngOnInit = function () {
        this._syncColumnDefName();
        if (this.headerText === undefined) {
            this.headerText = this._createDefaultHeaderText();
        }
        if (!this.dataAccessor) {
            this.dataAccessor =
                this._options.defaultDataAccessor || (function (data, name) { return data[name]; });
        }
        if (this._table) {
            // Provide the cell and headerCell directly to the table with the static `ViewChild` query,
            // since the columnDef will not pick up its content by the time the table finishes checking
            // its content and initializing the rows.
            this.columnDef.cell = this.cell;
            this.columnDef.headerCell = this.headerCell;
            this._table.addColumnDef(this.columnDef);
        }
        else {
            throw getTableTextColumnMissingParentTableError();
        }
    };
    CdkTextColumn.prototype.ngOnDestroy = function () {
        if (this._table) {
            this._table.removeColumnDef(this.columnDef);
        }
    };
    /**
     * Creates a default header text. Use the options' header text transformation function if one
     * has been provided. Otherwise simply capitalize the column name.
     */
    CdkTextColumn.prototype._createDefaultHeaderText = function () {
        var name = this.name;
        if (isDevMode() && !name) {
            throw getTableTextColumnMissingNameError();
        }
        if (this._options && this._options.defaultHeaderTextTransform) {
            return this._options.defaultHeaderTextTransform(name);
        }
        return name[0].toUpperCase() + name.slice(1);
    };
    /** Synchronizes the column definition name with the text column name. */
    CdkTextColumn.prototype._syncColumnDefName = function () {
        if (this.columnDef) {
            this.columnDef.name = this.name;
        }
    };
    /** @nocollapse */
    CdkTextColumn.ctorParameters = function () { return [
        { type: CdkTable, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TEXT_COLUMN_OPTIONS,] }] }
    ]; };
    CdkTextColumn.propDecorators = {
        name: [{ type: Input }],
        headerText: [{ type: Input }],
        dataAccessor: [{ type: Input }],
        justify: [{ type: Input }],
        columnDef: [{ type: ViewChild, args: [CdkColumnDef, { static: true },] }],
        cell: [{ type: ViewChild, args: [CdkCellDef, { static: true },] }],
        headerCell: [{ type: ViewChild, args: [CdkHeaderCellDef, { static: true },] }]
    };
CdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) { return new (t || CdkTextColumn)(ɵngcc0.ɵɵdirectiveInject(CdkTable, 8), ɵngcc0.ɵɵdirectiveInject(TEXT_COLUMN_OPTIONS, 8)); };
CdkTextColumn.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CdkTextColumn, selectors: [["cdk-text-column"]], viewQuery: function CdkTextColumn_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(CdkColumnDef, true);
        ɵngcc0.ɵɵstaticViewQuery(CdkCellDef, true);
        ɵngcc0.ɵɵstaticViewQuery(CdkHeaderCellDef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnDef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);
    } }, inputs: { justify: "justify", name: "name", headerText: "headerText", dataAccessor: "dataAccessor" }, decls: 3, vars: 0, consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]], template: function CdkTextColumn_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, 0);
        ɵngcc0.ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, "th", 1);
        ɵngcc0.ɵɵtemplate(2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);
        ɵngcc0.ɵɵelementContainerEnd();
    } }, directives: [ɵngcc1.CdkColumnDef, ɵngcc1.CdkHeaderCellDef, ɵngcc1.CdkCellDef, ɵngcc1.CdkHeaderCell, ɵngcc1.CdkCell], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CdkTextColumn, [{
        type: Component,
        args: [{
                selector: 'cdk-text-column',
                template: "\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
                encapsulation: ViewEncapsulation.None,
                // Change detection is intentionally not set to OnPush. This component's template will be provided
                // to the table to be inserted into its view. This is problematic when change detection runs since
                // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
                // mean's the template in the table's view will not have the updated value (and in fact will cause
                // an ExpressionChangedAfterItHasBeenCheckedError).
                // tslint:disable-next-line:validate-decorators
                changeDetection: ChangeDetectionStrategy.Default
            }]
    }], function () { return [{ type: CdkTable, decorators: [{
                type: Optional
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [TEXT_COLUMN_OPTIONS]
            }] }]; }, { justify: [{
            type: Input
        }], name: [{
            type: Input
        }], headerText: [{
            type: Input
        }], dataAccessor: [{
            type: Input
        }], columnDef: [{
            type: ViewChild,
            args: [CdkColumnDef, { static: true }]
        }], cell: [{
            type: ViewChild,
            args: [CdkCellDef, { static: true }]
        }], headerCell: [{
            type: ViewChild,
            args: [CdkHeaderCellDef, { static: true }]
        }] }); })();
    return CdkTextColumn;
}());
export { CdkTextColumn };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2VzbTUvdGFibGUvdGV4dC1jb2x1bW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQTZFTSxBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBY0EiLCJmaWxlIjoidGV4dC1jb2x1bW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPcHRpb25hbCwgVmlld0NoaWxkLCBWaWV3RW5jYXBzdWxhdGlvbiwgaXNEZXZNb2RlLCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2RrQ2VsbERlZiwgQ2RrQ29sdW1uRGVmLCBDZGtIZWFkZXJDZWxsRGVmIH0gZnJvbSAnLi9jZWxsJztcbmltcG9ydCB7IENka1RhYmxlIH0gZnJvbSAnLi90YWJsZSc7XG5pbXBvcnQgeyBnZXRUYWJsZVRleHRDb2x1bW5NaXNzaW5nUGFyZW50VGFibGVFcnJvciwgZ2V0VGFibGVUZXh0Q29sdW1uTWlzc2luZ05hbWVFcnJvciwgfSBmcm9tICcuL3RhYmxlLWVycm9ycyc7XG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgdGV4dCBjb2x1bW4gb3B0aW9ucy4gKi9cbmV4cG9ydCB2YXIgVEVYVF9DT0xVTU5fT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbigndGV4dC1jb2x1bW4tb3B0aW9ucycpO1xuLyoqXG4gKiBDb2x1bW4gdGhhdCBzaW1wbHkgc2hvd3MgdGV4dCBjb250ZW50IGZvciB0aGUgaGVhZGVyIGFuZCByb3cgY2VsbHMuIEFzc3VtZXMgdGhhdCB0aGUgdGFibGVcbiAqIGlzIHVzaW5nIHRoZSBuYXRpdmUgdGFibGUgaW1wbGVtZW50YXRpb24gKGA8dGFibGU+YCkuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIG5hbWUgb2YgdGhpcyBjb2x1bW4gd2lsbCBiZSB0aGUgaGVhZGVyIHRleHQgYW5kIGRhdGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gKiBUaGUgaGVhZGVyIHRleHQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgYGhlYWRlclRleHRgIGlucHV0LiBDZWxsIHZhbHVlcyBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoXG4gKiB0aGUgYGRhdGFBY2Nlc3NvcmAgaW5wdXQuIENoYW5nZSB0aGUgdGV4dCBqdXN0aWZpY2F0aW9uIHRvIHRoZSBzdGFydCBvciBlbmQgdXNpbmcgdGhlIGBqdXN0aWZ5YFxuICogaW5wdXQuXG4gKi9cbnZhciBDZGtUZXh0Q29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka1RleHRDb2x1bW4oX3RhYmxlLCBfb3B0aW9ucykge1xuICAgICAgICB0aGlzLl90YWJsZSA9IF90YWJsZTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgICAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBjZWxsIHZhbHVlcy4gKi9cbiAgICAgICAgdGhpcy5qdXN0aWZ5ID0gJ3N0YXJ0JztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2RrVGV4dENvbHVtbi5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKiBDb2x1bW4gbmFtZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGNvbHVtbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAvLyBXaXRoIEl2eSwgaW5wdXRzIGNhbiBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3RhdGljIHF1ZXJ5IHJlc3VsdHMgYXJlXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUuIEluIHRoYXQgY2FzZSwgd2UgZGVmZXIgdGhlIHN5bmNocm9uaXphdGlvbiB1bnRpbCBcIm5nT25Jbml0XCIgZmlyZXMuXG4gICAgICAgICAgICB0aGlzLl9zeW5jQ29sdW1uRGVmTmFtZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDZGtUZXh0Q29sdW1uLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc3luY0NvbHVtbkRlZk5hbWUoKTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRleHQgPSB0aGlzLl9jcmVhdGVEZWZhdWx0SGVhZGVyVGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kYXRhQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUFjY2Vzc29yID1cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmRlZmF1bHREYXRhQWNjZXNzb3IgfHwgKGZ1bmN0aW9uIChkYXRhLCBuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGFibGUpIHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGNlbGwgYW5kIGhlYWRlckNlbGwgZGlyZWN0bHkgdG8gdGhlIHRhYmxlIHdpdGggdGhlIHN0YXRpYyBgVmlld0NoaWxkYCBxdWVyeSxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb2x1bW5EZWYgd2lsbCBub3QgcGljayB1cCBpdHMgY29udGVudCBieSB0aGUgdGltZSB0aGUgdGFibGUgZmluaXNoZXMgY2hlY2tpbmdcbiAgICAgICAgICAgIC8vIGl0cyBjb250ZW50IGFuZCBpbml0aWFsaXppbmcgdGhlIHJvd3MuXG4gICAgICAgICAgICB0aGlzLmNvbHVtbkRlZi5jZWxsID0gdGhpcy5jZWxsO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5EZWYuaGVhZGVyQ2VsbCA9IHRoaXMuaGVhZGVyQ2VsbDtcbiAgICAgICAgICAgIHRoaXMuX3RhYmxlLmFkZENvbHVtbkRlZih0aGlzLmNvbHVtbkRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRUYWJsZVRleHRDb2x1bW5NaXNzaW5nUGFyZW50VGFibGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDZGtUZXh0Q29sdW1uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJsZS5yZW1vdmVDb2x1bW5EZWYodGhpcy5jb2x1bW5EZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVmYXVsdCBoZWFkZXIgdGV4dC4gVXNlIHRoZSBvcHRpb25zJyBoZWFkZXIgdGV4dCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBpZiBvbmVcbiAgICAgKiBoYXMgYmVlbiBwcm92aWRlZC4gT3RoZXJ3aXNlIHNpbXBseSBjYXBpdGFsaXplIHRoZSBjb2x1bW4gbmFtZS5cbiAgICAgKi9cbiAgICBDZGtUZXh0Q29sdW1uLnByb3RvdHlwZS5fY3JlYXRlRGVmYXVsdEhlYWRlclRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGdldFRhYmxlVGV4dENvbHVtbk1pc3NpbmdOYW1lRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJUZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0SGVhZGVyVGV4dFRyYW5zZm9ybShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICB9O1xuICAgIC8qKiBTeW5jaHJvbml6ZXMgdGhlIGNvbHVtbiBkZWZpbml0aW9uIG5hbWUgd2l0aCB0aGUgdGV4dCBjb2x1bW4gbmFtZS4gKi9cbiAgICBDZGtUZXh0Q29sdW1uLnByb3RvdHlwZS5fc3luY0NvbHVtbkRlZk5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRlZikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5EZWYubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2RrVGV4dENvbHVtbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstdGV4dC1jb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5nLWNvbnRhaW5lciBjZGtDb2x1bW5EZWY+XFxuICAgICAgPHRoIGNkay1oZWFkZXItY2VsbCAqY2RrSGVhZGVyQ2VsbERlZiBbc3R5bGUudGV4dC1hbGlnbl09XFxcImp1c3RpZnlcXFwiPlxcbiAgICAgICAge3toZWFkZXJUZXh0fX1cXG4gICAgICA8L3RoPlxcbiAgICAgIDx0ZCBjZGstY2VsbCAqY2RrQ2VsbERlZj1cXFwibGV0IGRhdGFcXFwiIFtzdHlsZS50ZXh0LWFsaWduXT1cXFwianVzdGlmeVxcXCI+XFxuICAgICAgICB7e2RhdGFBY2Nlc3NvcihkYXRhLCBuYW1lKX19XFxuICAgICAgPC90ZD5cXG4gICAgPC9uZy1jb250YWluZXI+XFxuICBcIixcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGRldGVjdGlvbiBpcyBpbnRlbnRpb25hbGx5IG5vdCBzZXQgdG8gT25QdXNoLiBUaGlzIGNvbXBvbmVudCdzIHRlbXBsYXRlIHdpbGwgYmUgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHRhYmxlIHRvIGJlIGluc2VydGVkIGludG8gaXRzIHZpZXcuIFRoaXMgaXMgcHJvYmxlbWF0aWMgd2hlbiBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bnMgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJpbmRpbmdzIGluIHRoaXMgdGVtcGxhdGUgd2lsbCBiZSBldmFsdWF0ZWQgX2FmdGVyXyB0aGUgdGFibGUncyB2aWV3IGlzIGV2YWx1YXRlZCwgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVhbidzIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgdGFibGUncyB2aWV3IHdpbGwgbm90IGhhdmUgdGhlIHVwZGF0ZWQgdmFsdWUgKGFuZCBpbiBmYWN0IHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcikuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YWxpZGF0ZS1kZWNvcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdFxuICAgICAgICAgICAgICAgIH1dIH1cbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENka1RleHRDb2x1bW4uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogQ2RrVGFibGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1RFWFRfQ09MVU1OX09QVElPTlMsXSB9XSB9XG4gICAgXTsgfTtcbiAgICBDZGtUZXh0Q29sdW1uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICBuYW1lOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICAgICAgaGVhZGVyVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGRhdGFBY2Nlc3NvcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgICAgIGp1c3RpZnk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgICAgICBjb2x1bW5EZWY6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW0Nka0NvbHVtbkRlZiwgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgICAgICBjZWxsOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtDZGtDZWxsRGVmLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV0sXG4gICAgICAgIGhlYWRlckNlbGw6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW0Nka0hlYWRlckNlbGxEZWYsIHsgc3RhdGljOiB0cnVlIH0sXSB9XVxuICAgIH07XG4gICAgcmV0dXJuIENka1RleHRDb2x1bW47XG59KCkpO1xuZXhwb3J0IHsgQ2RrVGV4dENvbHVtbiB9O1xuIl19