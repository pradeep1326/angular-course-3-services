{"version":3,"sources":["c:/Users/puttp/Desktop/Angular/workspace/angular-course-3-services/node_modules/@angular/cdk/bundles/cdk-platform.umd.js"],"names":[],"mappings":"AAAA;oGAC2E;kGACO;qDAC5C;0BACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAqEV,AAGC;;;;;;;;;;;;;;;kCAK6K;;;;;;;;;;;;;SAa9K;;;;;;gDAGC","file":"cdk-platform.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/platform', ['exports', '@angular/core', '@angular/common'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.platform = {}), global.ng.core, global.ng.common));\n}(this, (function (exports, i0, common) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Whether the current platform supports the V8 Break Iterator. The V8 check\n    // is necessary to detect all Blink based browsers.\n    var hasV8BreakIterator;\n    // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n    // cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n    // the consumer is providing a polyfilled `Map`. See:\n    // https://github.com/Microsoft/ChakraCore/issues/3189\n    // https://github.com/angular/components/issues/15687\n    try {\n        hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n    }\n    catch (_a) {\n        hasV8BreakIterator = false;\n    }\n    /**\n     * Service to detect the current platform by comparing the userAgent strings and\n     * checking browser-specific global properties.\n     */\n    var Platform = /** @class */ (function () {\n        /**\n         * @breaking-change 8.0.0 remove optional decorator\n         */\n        function Platform(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                common.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n        Platform.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        Platform.ctorParameters = function () { return [\n            { type: Object, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i0.PLATFORM_ID,] }] }\n        ]; };\n        Platform.ɵprov = i0.ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(i0.ɵɵinject(i0.PLATFORM_ID, 8)); }, token: Platform, providedIn: \"root\" });\n        return Platform;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var PlatformModule = /** @class */ (function () {\n        function PlatformModule() {\n        }\n        PlatformModule.decorators = [\n            { type: i0.NgModule, args: [{},] }\n        ];\n        return PlatformModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Cached result Set of input types support by the current browser. */\n    var supportedInputTypes;\n    /** Types of `<input>` that *might* be supported. */\n    var candidateInputTypes = [\n        // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n        // first changing it to something else:\n        // The specified value \"\" does not conform to the required format.\n        // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n        'color',\n        'button',\n        'checkbox',\n        'date',\n        'datetime-local',\n        'email',\n        'file',\n        'hidden',\n        'image',\n        'month',\n        'number',\n        'password',\n        'radio',\n        'range',\n        'reset',\n        'search',\n        'submit',\n        'tel',\n        'text',\n        'time',\n        'url',\n        'week',\n    ];\n    /** @returns The input types supported by this browser. */\n    function getSupportedInputTypes() {\n        // Result is cached.\n        if (supportedInputTypes) {\n            return supportedInputTypes;\n        }\n        // We can't check if an input type is not supported until we're on the browser, so say that\n        // everything is supported when not on the browser. We don't use `Platform` here since it's\n        // just a helper function and can't inject it.\n        if (typeof document !== 'object' || !document) {\n            supportedInputTypes = new Set(candidateInputTypes);\n            return supportedInputTypes;\n        }\n        var featureTestInput = document.createElement('input');\n        supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n            featureTestInput.setAttribute('type', value);\n            return featureTestInput.type === value;\n        }));\n        return supportedInputTypes;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Cached result of whether the user's browser supports passive event listeners. */\n    var supportsPassiveEvents;\n    /**\n     * Checks whether the user's browser supports passive event listeners.\n     * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n     */\n    function supportsPassiveEventListeners() {\n        if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n            try {\n                window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                    get: function () { return supportsPassiveEvents = true; }\n                }));\n            }\n            finally {\n                supportsPassiveEvents = supportsPassiveEvents || false;\n            }\n        }\n        return supportsPassiveEvents;\n    }\n    /**\n     * Normalizes an `AddEventListener` object to something that can be passed\n     * to `addEventListener` on any browser, no matter whether it supports the\n     * `options` parameter.\n     * @param options Object to be normalized.\n     */\n    function normalizePassiveListenerOptions(options) {\n        return supportsPassiveEventListeners() ? options : !!options.capture;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (RtlScrollAxisType) {\n        /**\n         * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\n         * all the way right.\n         */\n        RtlScrollAxisType[RtlScrollAxisType[\"NORMAL\"] = 0] = \"NORMAL\";\n        /**\n         * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n         * all the way right.\n         */\n        RtlScrollAxisType[RtlScrollAxisType[\"NEGATED\"] = 1] = \"NEGATED\";\n        /**\n         * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n         * all the way right.\n         */\n        RtlScrollAxisType[RtlScrollAxisType[\"INVERTED\"] = 2] = \"INVERTED\";\n    })(exports.RtlScrollAxisType || (exports.RtlScrollAxisType = {}));\n    /** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\n    var rtlScrollAxisType;\n    /** Check whether the browser supports scroll behaviors. */\n    function supportsScrollBehavior() {\n        return !!(typeof document == 'object' && 'scrollBehavior' in document.documentElement.style);\n    }\n    /**\n     * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n     * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n     */\n    function getRtlScrollAxisType() {\n        // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n        if (typeof document !== 'object' || !document) {\n            return exports.RtlScrollAxisType.NORMAL;\n        }\n        if (!rtlScrollAxisType) {\n            // Create a 1px wide scrolling container and a 2px wide content element.\n            var scrollContainer = document.createElement('div');\n            var containerStyle = scrollContainer.style;\n            scrollContainer.dir = 'rtl';\n            containerStyle.height = '1px';\n            containerStyle.width = '1px';\n            containerStyle.overflow = 'auto';\n            containerStyle.visibility = 'hidden';\n            containerStyle.pointerEvents = 'none';\n            containerStyle.position = 'absolute';\n            var content = document.createElement('div');\n            var contentStyle = content.style;\n            contentStyle.width = '2px';\n            contentStyle.height = '1px';\n            scrollContainer.appendChild(content);\n            document.body.appendChild(scrollContainer);\n            rtlScrollAxisType = exports.RtlScrollAxisType.NORMAL;\n            // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n            // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n            // dealing with one of the other two types of browsers.\n            if (scrollContainer.scrollLeft === 0) {\n                // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n                // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n                // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n                // return 0 when we read it again.\n                scrollContainer.scrollLeft = 1;\n                rtlScrollAxisType =\n                    scrollContainer.scrollLeft === 0 ? exports.RtlScrollAxisType.NEGATED : exports.RtlScrollAxisType.INVERTED;\n            }\n            scrollContainer.parentNode.removeChild(scrollContainer);\n        }\n        return rtlScrollAxisType;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var shadowDomIsSupported;\n    /** Checks whether the user's browser support Shadow DOM. */\n    function _supportsShadowDom() {\n        if (shadowDomIsSupported == null) {\n            var head = typeof document !== 'undefined' ? document.head : null;\n            shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n        }\n        return shadowDomIsSupported;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.Platform = Platform;\n    exports.PlatformModule = PlatformModule;\n    exports._supportsShadowDom = _supportsShadowDom;\n    exports.getRtlScrollAxisType = getRtlScrollAxisType;\n    exports.getSupportedInputTypes = getSupportedInputTypes;\n    exports.normalizePassiveListenerOptions = normalizePassiveListenerOptions;\n    exports.supportsPassiveEventListeners = supportsPassiveEventListeners;\n    exports.supportsScrollBehavior = supportsScrollBehavior;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}