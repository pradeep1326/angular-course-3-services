{"version":3,"sources":["c:/Users/puttp/Desktop/Angular/workspace/angular-course-3-services/node_modules/@angular/cdk/bundles/cdk-collections.umd.js"],"names":[],"mappings":"AAAA;oGAC2E;qGACU;qDAC/C;0BACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAiRT,AAGA;;;;;;gDACmN","file":"cdk-collections.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('rxjs'), require('@angular/core')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/collections', ['exports', 'tslib', 'rxjs', '@angular/core'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.collections = {}), global.tslib, global.rxjs, global.ng.core));\n}(this, (function (exports, tslib, rxjs, i0) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var DataSource = /** @class */ (function () {\n        function DataSource() {\n        }\n        return DataSource;\n    }());\n    /** Checks whether an object is a data source. */\n    function isDataSource(value) {\n        // Check if the value is a DataSource by observing if it has a connect function. Cannot\n        // be checked as an `instanceof DataSource` since people could create their own sources\n        // that match the interface, but don't extend DataSource.\n        return value && typeof value.connect === 'function';\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** DataSource wrapper for a native array. */\n    var ArrayDataSource = /** @class */ (function (_super) {\n        tslib.__extends(ArrayDataSource, _super);\n        function ArrayDataSource(_data) {\n            var _this = _super.call(this) || this;\n            _this._data = _data;\n            return _this;\n        }\n        ArrayDataSource.prototype.connect = function () {\n            return this._data instanceof rxjs.Observable ? this._data : rxjs.of(this._data);\n        };\n        ArrayDataSource.prototype.disconnect = function () { };\n        return ArrayDataSource;\n    }(DataSource));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Class to be used to power selecting one or more options from a list.\n     */\n    var SelectionModel = /** @class */ (function () {\n        function SelectionModel(_multiple, initiallySelectedValues, _emitChanges) {\n            var _this = this;\n            if (_multiple === void 0) { _multiple = false; }\n            if (_emitChanges === void 0) { _emitChanges = true; }\n            this._multiple = _multiple;\n            this._emitChanges = _emitChanges;\n            /** Currently-selected values. */\n            this._selection = new Set();\n            /** Keeps track of the deselected options that haven't been emitted by the change event. */\n            this._deselectedToEmit = [];\n            /** Keeps track of the selected options that haven't been emitted by the change event. */\n            this._selectedToEmit = [];\n            /** Event emitted when the value has changed. */\n            this.changed = new rxjs.Subject();\n            if (initiallySelectedValues && initiallySelectedValues.length) {\n                if (_multiple) {\n                    initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });\n                }\n                else {\n                    this._markSelected(initiallySelectedValues[0]);\n                }\n                // Clear the array in order to avoid firing the change event for preselected values.\n                this._selectedToEmit.length = 0;\n            }\n        }\n        Object.defineProperty(SelectionModel.prototype, \"selected\", {\n            /** Selected values. */\n            get: function () {\n                if (!this._selected) {\n                    this._selected = Array.from(this._selection.values());\n                }\n                return this._selected;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Selects a value or an array of values.\n         */\n        SelectionModel.prototype.select = function () {\n            var _this = this;\n            var values = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                values[_i] = arguments[_i];\n            }\n            this._verifyValueAssignment(values);\n            values.forEach(function (value) { return _this._markSelected(value); });\n            this._emitChangeEvent();\n        };\n        /**\n         * Deselects a value or an array of values.\n         */\n        SelectionModel.prototype.deselect = function () {\n            var _this = this;\n            var values = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                values[_i] = arguments[_i];\n            }\n            this._verifyValueAssignment(values);\n            values.forEach(function (value) { return _this._unmarkSelected(value); });\n            this._emitChangeEvent();\n        };\n        /**\n         * Toggles a value between selected and deselected.\n         */\n        SelectionModel.prototype.toggle = function (value) {\n            this.isSelected(value) ? this.deselect(value) : this.select(value);\n        };\n        /**\n         * Clears all of the selected values.\n         */\n        SelectionModel.prototype.clear = function () {\n            this._unmarkAll();\n            this._emitChangeEvent();\n        };\n        /**\n         * Determines whether a value is selected.\n         */\n        SelectionModel.prototype.isSelected = function (value) {\n            return this._selection.has(value);\n        };\n        /**\n         * Determines whether the model does not have a value.\n         */\n        SelectionModel.prototype.isEmpty = function () {\n            return this._selection.size === 0;\n        };\n        /**\n         * Determines whether the model has a value.\n         */\n        SelectionModel.prototype.hasValue = function () {\n            return !this.isEmpty();\n        };\n        /**\n         * Sorts the selected values based on a predicate function.\n         */\n        SelectionModel.prototype.sort = function (predicate) {\n            if (this._multiple && this.selected) {\n                this._selected.sort(predicate);\n            }\n        };\n        /**\n         * Gets whether multiple values can be selected.\n         */\n        SelectionModel.prototype.isMultipleSelection = function () {\n            return this._multiple;\n        };\n        /** Emits a change event and clears the records of selected and deselected values. */\n        SelectionModel.prototype._emitChangeEvent = function () {\n            // Clear the selected values so they can be re-cached.\n            this._selected = null;\n            if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n                this.changed.next({\n                    source: this,\n                    added: this._selectedToEmit,\n                    removed: this._deselectedToEmit\n                });\n                this._deselectedToEmit = [];\n                this._selectedToEmit = [];\n            }\n        };\n        /** Selects a value. */\n        SelectionModel.prototype._markSelected = function (value) {\n            if (!this.isSelected(value)) {\n                if (!this._multiple) {\n                    this._unmarkAll();\n                }\n                this._selection.add(value);\n                if (this._emitChanges) {\n                    this._selectedToEmit.push(value);\n                }\n            }\n        };\n        /** Deselects a value. */\n        SelectionModel.prototype._unmarkSelected = function (value) {\n            if (this.isSelected(value)) {\n                this._selection.delete(value);\n                if (this._emitChanges) {\n                    this._deselectedToEmit.push(value);\n                }\n            }\n        };\n        /** Clears out the selected values. */\n        SelectionModel.prototype._unmarkAll = function () {\n            var _this = this;\n            if (!this.isEmpty()) {\n                this._selection.forEach(function (value) { return _this._unmarkSelected(value); });\n            }\n        };\n        /**\n         * Verifies the value assignment and throws an error if the specified value array is\n         * including multiple values while the selection model is not supporting multiple values.\n         */\n        SelectionModel.prototype._verifyValueAssignment = function (values) {\n            if (values.length > 1 && !this._multiple) {\n                throw getMultipleValuesInSingleSelectionError();\n            }\n        };\n        return SelectionModel;\n    }());\n    /**\n     * Returns an error that reports that multiple values are passed into a selection model\n     * with a single value.\n     * @docs-private\n     */\n    function getMultipleValuesInSingleSelectionError() {\n        return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n    }\n\n    /**\n     * Class to coordinate unique selection based on name.\n     * Intended to be consumed as an Angular service.\n     * This service is needed because native radio change events are only fired on the item currently\n     * being selected, and we still need to uncheck the previous selection.\n     *\n     * This service does not *store* any IDs and names because they may change at any time, so it is\n     * less error-prone if they are simply passed through when the events occur.\n     */\n    var UniqueSelectionDispatcher = /** @class */ (function () {\n        function UniqueSelectionDispatcher() {\n            this._listeners = [];\n        }\n        /**\n         * Notify other items that selection for the given name has been set.\n         * @param id ID of the item.\n         * @param name Name of the item.\n         */\n        UniqueSelectionDispatcher.prototype.notify = function (id, name) {\n            var e_1, _a;\n            try {\n                for (var _b = tslib.__values(this._listeners), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var listener = _c.value;\n                    listener(id, name);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        };\n        /**\n         * Listen for future changes to item selection.\n         * @return Function used to deregister listener\n         */\n        UniqueSelectionDispatcher.prototype.listen = function (listener) {\n            var _this = this;\n            this._listeners.push(listener);\n            return function () {\n                _this._listeners = _this._listeners.filter(function (registered) {\n                    return listener !== registered;\n                });\n            };\n        };\n        UniqueSelectionDispatcher.prototype.ngOnDestroy = function () {\n            this._listeners = [];\n        };\n        UniqueSelectionDispatcher.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        UniqueSelectionDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\n        return UniqueSelectionDispatcher;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.ArrayDataSource = ArrayDataSource;\n    exports.DataSource = DataSource;\n    exports.SelectionModel = SelectionModel;\n    exports.UniqueSelectionDispatcher = UniqueSelectionDispatcher;\n    exports.getMultipleValuesInSingleSelectionError = getMultipleValuesInSingleSelectionError;\n    exports.isDataSource = isDataSource;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}