/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __decorate, __metadata, __param, __read } from "tslib";
import { Injectable, Optional } from '../di';
import { ivyEnabled } from '../ivy_switch';
import { Compiler } from './compiler';
import * as ɵngcc0 from '../r3_symbols';
var _SEPARATOR = '#';
var FACTORY_CLASS_SUFFIX = 'NgFactory';
/**
 * Configuration for SystemJsNgModuleLoader.
 * token.
 *
 * @publicApi
 * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoaderConfig`
 * is part of its implementation. See `LoadChildren` for more details.
 */
var SystemJsNgModuleLoaderConfig = /** @class */ (function () {
    function SystemJsNgModuleLoaderConfig() {
    }
    return SystemJsNgModuleLoaderConfig;
}());
export { SystemJsNgModuleLoaderConfig };
var DEFAULT_CONFIG = {
    factoryPathPrefix: '',
    factoryPathSuffix: '.ngfactory',
};
/**
 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
 * @publicApi
 * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoader` is
 * part of its implementation. See `LoadChildren` for more details.
 */
var SystemJsNgModuleLoader = /** @class */ (function () {
    function SystemJsNgModuleLoader(_compiler, config) {
        this._compiler = _compiler;
        this._config = config || DEFAULT_CONFIG;
    }
    SystemJsNgModuleLoader.prototype.load = function (path) {
        var legacyOfflineMode = !ivyEnabled && this._compiler instanceof Compiler;
        return legacyOfflineMode ? this.loadFactory(path) : this.loadAndCompile(path);
    };
    SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
        var _this = this;
        var _a = __read(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];
        if (exportName === undefined) {
            exportName = 'default';
        }
        return System.import(module)
            .then(function (module) { return module[exportName]; })
            .then(function (type) { return checkNotEmpty(type, module, exportName); })
            .then(function (type) { return _this._compiler.compileModuleAsync(type); });
    };
    SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
        var _a = __read(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];
        var factoryClassSuffix = FACTORY_CLASS_SUFFIX;
        if (exportName === undefined) {
            exportName = 'default';
            factoryClassSuffix = '';
        }
        return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
            .then(function (module) { return module[exportName + factoryClassSuffix]; })
            .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
    };
    SystemJsNgModuleLoader = __decorate([ __param(1, Optional()),
        __metadata("design:paramtypes", [Compiler, SystemJsNgModuleLoaderConfig])
    ], SystemJsNgModuleLoader);
SystemJsNgModuleLoader.ɵfac = function SystemJsNgModuleLoader_Factory(t) { return new (t || SystemJsNgModuleLoader)(ɵngcc0.ɵɵinject(Compiler), ɵngcc0.ɵɵinject(SystemJsNgModuleLoaderConfig, 8)); };
SystemJsNgModuleLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SystemJsNgModuleLoader, factory: function (t) { return SystemJsNgModuleLoader.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.setClassMetadata(SystemJsNgModuleLoader, [{
        type: Injectable
    }], function () { return [{ type: Compiler }, { type: SystemJsNgModuleLoaderConfig, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return SystemJsNgModuleLoader;
}());
export { SystemJsNgModuleLoader };
function checkNotEmpty(value, modulePath, exportName) {
    if (!value) {
        throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
    }
    return value;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3B1dHRwL0Rlc2t0b3AvQW5ndWxhci93b3Jrc3BhY2UvYW5ndWxhci1jb3Vyc2UtMy1zZXJ2aWNlcy9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9lc201L3NyYy9saW5rZXIvc3lzdGVtX2pzX25nX21vZHVsZV9mYWN0b3J5X2xvYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0F5RHlDLEFBRWxDOzs7Ozs7Ozs7a0NBRXdCIiwiZmlsZSI6InN5c3RlbV9qc19uZ19tb2R1bGVfZmFjdG9yeV9sb2FkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3BhcmFtLCBfX3JlYWQgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnLi4vZGknO1xuaW1wb3J0IHsgaXZ5RW5hYmxlZCB9IGZyb20gJy4uL2l2eV9zd2l0Y2gnO1xuaW1wb3J0IHsgQ29tcGlsZXIgfSBmcm9tICcuL2NvbXBpbGVyJztcbnZhciBfU0VQQVJBVE9SID0gJyMnO1xudmFyIEZBQ1RPUllfQ0xBU1NfU1VGRklYID0gJ05nRmFjdG9yeSc7XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuXG4gKiB0b2tlbi5cbiAqXG4gKiBAcHVibGljQXBpXG4gKiBAZGVwcmVjYXRlZCB0aGUgYHN0cmluZ2AgZm9ybSBvZiBgbG9hZENoaWxkcmVuYCBpcyBkZXByZWNhdGVkLCBhbmQgYFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWdgXG4gKiBpcyBwYXJ0IG9mIGl0cyBpbXBsZW1lbnRhdGlvbi4gU2VlIGBMb2FkQ2hpbGRyZW5gIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbnZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcoKSB7XG4gICAgfVxuICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xufSgpKTtcbmV4cG9ydCB7IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcgfTtcbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgZmFjdG9yeVBhdGhTdWZmaXg6ICcubmdmYWN0b3J5Jyxcbn07XG4vKipcbiAqIE5nTW9kdWxlRmFjdG9yeUxvYWRlciB0aGF0IHVzZXMgU3lzdGVtSlMgdG8gbG9hZCBOZ01vZHVsZUZhY3RvcnlcbiAqIEBwdWJsaWNBcGlcbiAqIEBkZXByZWNhdGVkIHRoZSBgc3RyaW5nYCBmb3JtIG9mIGBsb2FkQ2hpbGRyZW5gIGlzIGRlcHJlY2F0ZWQsIGFuZCBgU3lzdGVtSnNOZ01vZHVsZUxvYWRlcmAgaXNcbiAqIHBhcnQgb2YgaXRzIGltcGxlbWVudGF0aW9uLiBTZWUgYExvYWRDaGlsZHJlbmAgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcihfY29tcGlsZXIsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9jb21waWxlciA9IF9jb21waWxlcjtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnIHx8IERFRkFVTFRfQ09ORklHO1xuICAgIH1cbiAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGxlZ2FjeU9mZmxpbmVNb2RlID0gIWl2eUVuYWJsZWQgJiYgdGhpcy5fY29tcGlsZXIgaW5zdGFuY2VvZiBDb21waWxlcjtcbiAgICAgICAgcmV0dXJuIGxlZ2FjeU9mZmxpbmVNb2RlID8gdGhpcy5sb2FkRmFjdG9yeShwYXRoKSA6IHRoaXMubG9hZEFuZENvbXBpbGUocGF0aCk7XG4gICAgfTtcbiAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkQW5kQ29tcGlsZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCAyKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0TmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydChtb2R1bGUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eSh0eXBlLCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModHlwZSk7IH0pO1xuICAgIH07XG4gICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEZhY3RvcnkgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgMiksIG1vZHVsZSA9IF9hWzBdLCBleHBvcnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciBmYWN0b3J5Q2xhc3NTdWZmaXggPSBGQUNUT1JZX0NMQVNTX1NVRkZJWDtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0TmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGZhY3RvcnlDbGFzc1N1ZmZpeCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeXN0ZW0uaW1wb3J0KHRoaXMuX2NvbmZpZy5mYWN0b3J5UGF0aFByZWZpeCArIG1vZHVsZSArIHRoaXMuX2NvbmZpZy5mYWN0b3J5UGF0aFN1ZmZpeClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lICsgZmFjdG9yeUNsYXNzU3VmZml4XTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBjaGVja05vdEVtcHR5KGZhY3RvcnksIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pO1xuICAgIH07XG4gICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29tcGlsZXIsIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWddKVxuICAgIF0sIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIpO1xuICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xufSgpKTtcbmV4cG9ydCB7IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgfTtcbmZ1bmN0aW9uIGNoZWNrTm90RW1wdHkodmFsdWUsIG1vZHVsZVBhdGgsIGV4cG9ydE5hbWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kICdcIiArIGV4cG9ydE5hbWUgKyBcIicgaW4gJ1wiICsgbW9kdWxlUGF0aCArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuIl19